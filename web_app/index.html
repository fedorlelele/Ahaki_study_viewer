<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ahaki Study Viewer</title>
    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "e88f0886e93c42adae0ff3dd06807843"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->
    <style>
      :root {
        --bg-1: #ffffff;
        --bg-2: #f1f5f9;
        --ink: #111111;
        --muted: #2b2b2b;
        --accent: #0b5cab;
        --card: #ffffff;
        --line: #4a4a4a;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
        color: var(--ink);
        background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
        min-height: 100vh;
      }
      header {
        padding: 28px 24px 10px;
      }
      .header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
      }
      h1 {
        margin: 0;
        font-size: clamp(24px, 4vw, 36px);
        letter-spacing: 0.5px;
      }
      .subtitle {
        color: var(--muted);
        margin-top: 6px;
        font-size: 14px;
      }
      .controls {
        display: grid;
        grid-template-columns: 1.6fr 1fr 1fr 1fr 1fr auto auto;
        gap: 10px;
        padding: 14px 24px 20px;
      }
      .controls input,
      .controls select,
      .controls button {
        padding: 10px 12px;
        border: 2px solid var(--line);
        border-radius: 10px;
        background: #fff;
        font-size: 14px;
      }
      .controls button {
        background: var(--accent);
        color: #fff;
        border: none;
        cursor: pointer;
      }
      .toolbar button {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .toolbar select {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .toolbar {
        padding: 0 24px 18px;
        display: flex;
        gap: 16px;
        align-items: center;
        color: var(--muted);
        font-size: 13px;
      }
      .toolbar.main {
        flex-wrap: wrap;
        gap: 10px;
      }
      .toolbar .auth-panel {
        margin-top: 0;
      }
      .results {
        padding: 0 24px 40px;
        display: grid;
        gap: 14px;
      }
      .card {
        background: var(--card);
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 16px 18px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        animation: fadeIn 250ms ease-in;
      }
      .meta {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        color: var(--muted);
        font-size: 12px;
      }
      .stem {
        margin: 10px 0 8px;
        font-size: 16px;
      }
      .case-text {
        margin: 10px 0 6px;
        padding: 8px 10px;
        background: #fff7e6;
        border-left: 4px solid #b67b0b;
        font-size: 13px;
        white-space: pre-wrap;
      }
      .choices {
        padding-left: 18px;
        margin: 6px 0;
      }
      .choice-btn {
        display: inline-block;
        width: 100%;
        text-align: left;
        border: none;
        background: transparent;
        padding: 4px 0;
        font-size: 14px;
        color: var(--ink);
        cursor: pointer;
      }
      .choice-btn:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }
      .choice-btn.selected {
        background: #e6f0ff;
        border-radius: 6px;
      }
      .choice-btn.correct {
        background: #e6f7ed;
        color: #0b5c2b;
        border-radius: 6px;
      }
      .choice-btn.incorrect {
        background: #ffe7ea;
        color: #7a0015;
        border-radius: 6px;
      }
      .choice-feedback {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      .tagline {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
      }
      .tag-label {
        font-weight: 600;
      }
      .chip-link {
        display: inline-block;
        margin: 2px 6px 0 0;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #fff;
        color: var(--muted);
        font-size: 12px;
        text-decoration: none;
        cursor: pointer;
      }
      .chip-link:hover {
        color: var(--ink);
        border-color: var(--accent);
      }
      .report-btn.reported {
        background: #ffe7ea;
        border-color: #b00020;
        color: #7a0015;
      }
      .proposal-list {
        margin-top: 8px;
        padding: 8px;
        border: 1px dashed var(--line);
        border-radius: 8px;
        background: #f8fafc;
        font-size: 0.9em;
      }
      .proposal-item {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px dashed var(--line);
      }
      .proposal-item:first-child {
        margin-top: 0;
        padding-top: 0;
        border-top: none;
      }
      .proposal-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .proposal-label {
        font-weight: 600;
        margin-right: 6px;
      }
      .answer {
        margin-top: 10px;
        padding: 8px 10px;
        border-left: 4px solid var(--accent);
        background: #e6f0ff;
        font-size: 13px;
        display: none;
      }
      .explanation {
        margin-top: 8px;
        padding: 8px 10px;
        border-left: 4px solid #0b7a5c;
        background: #e8f7f2;
        font-size: 13px;
        white-space: pre-wrap;
        display: none;
      }
      .answer-stats {
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px dashed var(--line);
        font-size: 12px;
        color: var(--muted);
      }
      .card-actions {
        margin-top: 10px;
      }
      .note {
        color: var(--muted);
        font-size: 12px;
      }
      .update-list {
        margin: 6px 0 8px;
        padding-left: 18px;
        font-size: 12px;
      }
      .update-list li {
        margin: 4px 0;
      }
      .user-readme {
        margin: 6px 0;
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
        white-space: pre-wrap;
      }
      details.inline {
        margin-top: 8px;
      }
      details.inline > summary {
        cursor: pointer;
        font-size: 12px;
        color: var(--muted);
      }
      details.inline > summary.inline-summary {
        list-style: none;
        display: inline-block;
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
        color: var(--ink);
      }
      details.inline > summary.inline-summary::-webkit-details-marker {
        display: none;
      }
      .edit-panel {
        margin-top: 6px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
      }
      .edit-panel input,
      .edit-panel select,
      .edit-panel textarea,
      .edit-panel button {
        margin-top: 6px;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid var(--line);
        font-size: 12px;
      }
      .edit-panel textarea {
        width: 100%;
      }
      .explanation-header {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .explanation-body {
        margin-top: 6px;
        white-space: pre-wrap;
      }
      .inline-details[open] {
        flex-basis: 100%;
      }
      .inline-details[open] .edit-panel {
        width: 100%;
      }
      .auth-panel {
        margin-top: 8px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
      }
      .auth-panel input {
        width: 220px;
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        margin-right: 6px;
      }
      .history-panel {
        margin-top: 10px;
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 13px;
      }
      .history-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .history-controls input,
      .history-controls select,
      .history-controls button {
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        background: #fff;
        font-size: 12px;
      }
      .history-list {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }
      .history-item {
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px 10px;
        background: #f8fafc;
      }
      .history-meta {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      .history-body {
        font-size: 13px;
        white-space: pre-wrap;
      }
      .history-item button {
        margin-top: 6px;
        padding: 4px 8px;
        font-size: 12px;
      }
      .proposal-panel {
        margin-top: 10px;
      }
      .proposal-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 10px;
      }
      .proposal-controls input,
      .proposal-controls select,
      .proposal-controls button {
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        background: #fff;
        font-size: 12px;
      }
      .proposal-list-wide {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        padding: 8px;
        font-size: 12px;
      }
      .proposal-row {
        border-top: 1px solid var(--line);
        padding: 8px 0;
      }
      .proposal-row:first-child {
        border-top: none;
        padding-top: 0;
      }
      .proposal-meta {
        color: var(--muted);
        font-size: 11px;
        margin-bottom: 4px;
      }
      .auth-panel .note {
        margin-top: 6px;
        color: var(--muted);
        font-size: 11px;
      }
      .auth-toggle {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .auth-container {
        padding: 0 24px 12px;
      }
      .auth-panel[hidden] {
        display: none;
      }
      .card-actions button,
      .card-actions select {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .request-btn {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--accent);
        background: #fff;
        color: var(--accent);
        cursor: pointer;
        font-size: 12px;
      }
      .request-btn.reported {
        background: #ffe7ea;
        border-color: #b00020;
        color: #7a0015;
      }
      .request-panel {
        margin-top: 6px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
        flex-basis: 100%;
        width: 100%;
      }
      .request-panel textarea,
      .request-panel button {
        margin-top: 6px;
        font-size: 12px;
      }
      .request-panel textarea {
        width: 100%;
        min-height: 96px;
        resize: vertical;
      }
      .show .answer { display: block; }
      .show-explanation .answer { display: block; }
      .show-explanation .explanation { display: block; }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(6px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @media (max-width: 900px) {
        .controls {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-row">
        <h1>Ahaki Study Viewer</h1>
        <button id="authToggleBtn" class="auth-toggle" aria-expanded="false">教師ログイン</button>
      </div>
      <div class="subtitle">検索・絞り込み・学習用の簡易ビュー</div>
      <div class="subtitle"><a href="./simple.html">かんたんビューを開く</a></div>
      <details class="inline" id="updateInfo">
        <summary>更新情報</summary>
        <div class="card-actions">
          <ul class="update-list" id="updateList"></ul>
          <button id="updateMoreBtn" type="button">さらに表示</button>
          <div class="note" id="updateEmpty" hidden>更新情報はありません。</div>
        </div>
      </details>
      <details class="inline" id="userReadme">
        <summary>利用ガイド</summary>
        <div class="card-actions">
          <pre class="user-readme" id="userReadmeText">読み込み中...</pre>
        </div>
      </details>
      <details class="inline" id="historyPanel" hidden>
        <summary>編集履歴</summary>
        <div class="history-panel">
          <div class="history-controls">
            <input id="historySerial" type="text" placeholder="シリアル (例: A01-001)" />
            <select id="historyKind">
              <option value="">すべて</option>
              <option value="explanation">解説</option>
              <option value="tags">タグ</option>
              <option value="subtopics">小項目</option>
            </select>
            <button id="historyFetchBtn" type="button">履歴を取得</button>
          </div>
          <div class="history-list" id="historyList"></div>
          <div class="note" id="historyEmpty" hidden>履歴はありません。</div>
        </div>
      </details>
      <details class="inline" id="proposalPanel" hidden>
        <summary>修正提案一覧</summary>
        <div class="proposal-panel">
          <div class="proposal-controls">
            <input id="proposalSerial" type="text" placeholder="シリアル (任意)" />
            <select id="proposalStatus">
              <option value="open">未処理</option>
              <option value="applied">反映済み</option>
              <option value="rejected">却下</option>
              <option value="">すべて</option>
            </select>
            <button id="proposalFetchBtn" type="button">提案を取得</button>
          </div>
          <div class="proposal-list-wide" id="proposalList"></div>
          <div class="note" id="proposalEmpty" hidden>提案はありません。</div>
        </div>
      </details>
      <div class="auth-container">
        <div class="auth-panel" id="teacherAuth" hidden>
          <div id="authStatus" class="note">未ログイン</div>
        <div id="authForm">
          <input id="authEmail" type="email" placeholder="メールアドレス" />
          <input id="authPassword" type="password" placeholder="パスワード" />
          <button id="authLoginBtn" type="button">ログイン</button>
        </div>
        <details class="inline" id="teacherSignupPanel">
          <summary>教師アカウントを申請</summary>
          <div class="edit-panel">
            <input id="signupEmail" type="email" placeholder="メールアドレス" />
            <input id="signupPassword" type="password" placeholder="パスワード" />
            <input id="signupPasswordConfirm" type="password" placeholder="パスワード（確認）" />
            <input id="signupNote" type="text" placeholder="申請理由（任意）" />
            <button id="signupBtn" type="button">申請する</button>
            <div class="note">申請後、管理者の承認が必要です。</div>
          </div>
        </details>
        <div id="authActions" hidden>
          <button id="authLogoutBtn" type="button">ログアウト</button>
        </div>
        <div id="authMessage" class="note"></div>
        </div>
      </div>
    </header>

    <main role="main" aria-label="学習ビュー">
    <div class="controls" role="search" aria-label="検索と絞り込み">
      <input id="keyword" type="text" placeholder="キーワード検索（例: #解剖学 筋）" aria-label="キーワード検索" />
      <details class="inline">
        <summary>詳細フィルタ</summary>
        <div class="row">
          <select id="subjectSelect" aria-label="科目の選択"><option value="">科目</option></select>
          <select id="subtopicSelect" aria-label="小項目の選択"><option value="">小項目</option></select>
          <select id="examTypeSelect" aria-label="試験種別の選択">
            <option value="">種別</option>
            <option value="A">A</option>
            <option value="B">B</option>
          </select>
          <select id="sessionSelect" aria-label="試験回数の選択"><option value="">回数</option></select>
          <input id="sessionFrom" type="number" min="1" placeholder="回数From" aria-label="試験回数の開始" />
          <input id="sessionTo" type="number" min="1" placeholder="回数To" aria-label="試験回数の終了" />
        </div>
        <div class="row">
          <label><input type="checkbox" id="hasExplanation" /> 解説あり</label>
          <label><input type="checkbox" id="hasTags" /> タグあり</label>
          <label><input type="checkbox" id="hasSubtopics" /> 小項目あり</label>
        </div>
      </details>
      <button id="searchBtn" aria-label="検索を実行">検索</button>
      <button id="resetBtn" aria-label="検索条件をリセット">リセット</button>
    </div>

    <div class="toolbar">
      <label><input type="checkbox" id="toggleAnswer" aria-label="正答を表示" /> 正答を表示</label>
      <label><input type="checkbox" id="toggleExplanation" aria-label="正答と解説を表示" /> 正答・解説を表示</label>
      <span id="countInfo" aria-live="polite"></span>
    </div>

    <div class="toolbar main">
      <button id="copyAllBtn" aria-label="検索結果をコピー">検索結果をコピー</button>
      <button id="resetAnswersBtn" aria-label="回答履歴をリセット">回答履歴をリセット</button>
      <select id="sortSession" aria-label="並び替え">
        <option value="">並び替え</option>
        <option value="desc" selected>新しい順</option>
        <option value="asc">古い順</option>
        <option value="count_desc">回答数が多い順</option>
        <option value="count_asc">回答数が少ない順</option>
        <option value="correct_desc">正答数が多い順</option>
        <option value="correct_asc">正答数が少ない順</option>
        <option value="rate_desc">正答率が高い順</option>
        <option value="rate_asc">正答率が低い順</option>
      </select>
      <label><input type="checkbox" id="showAnswered" checked /> 回答済みの問題を表示</label>
    </div>
    <div class="results" id="results" role="region" aria-live="polite" aria-label="検索結果"></div>
    <div class="toolbar" id="resultsMore"></div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="./config.js"></script>
    <script>
      const SUPABASE_URL = window.SUPABASE_URL || "";
      const SUPABASE_KEY = window.SUPABASE_KEY || "";
      const supabaseClient =
        window.supabase && SUPABASE_URL && SUPABASE_KEY
          ? window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY)
          : null;
      const API_BASE =
        localStorage.getItem("reportApiBase") ||
        (location.port === "8001" ? "" : "http://127.0.0.1:8001");
      const state = {
        questions: [],
        indexBySubject: {},
        indexBySubtopic: {},
        subtopicsBySubject: {},
        answeredMap: {},
        subtopicCatalog: {},
        teacherSession: null,
        teacherUserId: null,
        updateLog: [],
        updateShown: 0,
        orderIndexBySerial: {},
        overridesBySerial: {},
        overridesLoaded: new Set(),
        editRequestsBySerial: {},
        editRequestsLoaded: new Set(),
        answerStatsBySerial: {},
        answerStatsLoaded: new Set()
      };

      function normalizeAscii(text) {
        return (text || "")
          .replace(/[Ａ-Ｚａ-ｚ０-９]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0))
          .replace(/[‐‑‒–—―−ーｰ－]/g, "-");
      }

      function normalizeSerialTerm(raw) {
        if (!raw) return "";
        let text = normalizeAscii(raw).toUpperCase();
        text = text.replace(/\s+/g, "");
        text = text.replace(/^[^A-Z0-9]+|[^A-Z0-9]+$/g, "");
        let match = text.match(/^([AB])(\d{2})(\d{3})$/);
        if (match) return `${match[1]}${match[2]}-${match[3]}`;
        match = text.match(/^([AB])(\d{1,2})-(\d{1,3})$/);
        if (match) {
          return `${match[1]}${match[2].padStart(2, "0")}-${match[3].padStart(3, "0")}`;
        }
        match = text.match(/^([AB])(\d{4,5})$/);
        if (match) {
          const digits = match[2];
          const session = digits.slice(0, -3).padStart(2, "0");
          const number = digits.slice(-3).padStart(3, "0");
          return `${match[1]}${session}-${number}`;
        }
        return "";
      }

      function populateSelect(select, items) {
        const first = select.querySelector("option");
        select.innerHTML = "";
        if (first) {
          select.appendChild(first);
        }
        items.forEach(item => {
          const opt = document.createElement("option");
          opt.value = item;
          opt.textContent = item;
          select.appendChild(opt);
        });
      }

      function loadData() {
        return Promise.all([
          fetch("../output/web/questions.json").then(r => r.json()),
          fetch("../output/web/index/index_by_subject.json").then(r => r.json()),
          fetch("../output/web/index/index_by_subtopic.json").then(r => r.json())
        ]).then(([questions, bySubject, bySubtopic]) => {
          state.questions = questions;
          state.indexBySubject = bySubject;
          state.indexBySubtopic = bySubtopic;
          state.subtopicsBySubject = buildSubtopicsBySubject(questions);
          state.orderIndexBySerial = {};
          questions.forEach((q, idx) => {
            if (q && q.serial) state.orderIndexBySerial[q.serial] = idx;
          });
        });
      }

      function loadSubtopicCatalog() {
        return fetch("../config/subtopics_catalog.json")
          .then(r => (r.ok ? r.json() : {}))
          .then(data => {
            state.subtopicCatalog = data || {};
          })
          .catch(() => {
            state.subtopicCatalog = {};
          });
      }

      function loadUpdateLog() {
        return fetch("../output/web/update_log.json")
          .then(r => (r.ok ? r.json() : []))
          .then(data => {
            state.updateLog = Array.isArray(data) ? data : [];
          })
          .catch(() => {
            state.updateLog = [];
          });
      }

      function loadUserReadme() {
        return fetch("./USER_README.md")
          .then(r => (r.ok ? r.text() : "利用ガイドを読み込めませんでした。"))
          .then(text => {
            const target = document.getElementById("userReadmeText");
            if (target) {
              target.textContent = text;
            }
          })
          .catch(() => {
            const target = document.getElementById("userReadmeText");
            if (target) {
              target.textContent = "利用ガイドを読み込めませんでした。";
            }
          });
      }

      function renderUpdateLog(targetCount) {
        const list = document.getElementById("updateList");
        const moreBtn = document.getElementById("updateMoreBtn");
        const empty = document.getElementById("updateEmpty");
        if (!list || !moreBtn || !empty) return;

        const total = state.updateLog.length;
        if (!total) {
          list.innerHTML = "";
          moreBtn.hidden = true;
          empty.hidden = false;
          state.updateShown = 0;
          return;
        }

        empty.hidden = true;
        const count = Math.min(targetCount, total);
        list.innerHTML = "";
        state.updateLog.slice(0, count).forEach(item => {
          const li = document.createElement("li");
          li.textContent = `${item.date}　${item.text}`;
          list.appendChild(li);
        });
        state.updateShown = count;
        moreBtn.hidden = state.updateShown >= total;
      }

      function buildSubtopicsBySubject(questions) {
        const map = {};
        questions.forEach(q => {
          const subject = q.subject || "";
          const subs = q.subtopics || [];
          if (!map[subject]) map[subject] = new Set();
          subs.forEach(s => map[subject].add(s));
        });
        const out = {};
        Object.keys(map).forEach(subject => {
          out[subject] = Array.from(map[subject]).sort();
        });
        return out;
      }

      function updateSubtopicOptions(subject) {
        const select = document.getElementById("subtopicSelect");
        const baseOption = document.createElement("option");
        baseOption.value = "";
        baseOption.textContent = subject ? "小項目" : "小項目(科目選択後)";
        select.innerHTML = "";
        select.appendChild(baseOption);
        if (!subject) {
          select.disabled = true;
          return;
        }
        select.disabled = false;
        const items = state.subtopicsBySubject[subject] || [];
        items.forEach(item => {
          const opt = document.createElement("option");
          opt.value = item;
          opt.textContent = item;
          select.appendChild(opt);
        });
      }

      function applyFilters({ subject, subtopic, keyword }) {
        const subjectSelect = document.getElementById("subjectSelect");
        const subtopicSelect = document.getElementById("subtopicSelect");
        const keywordInput = document.getElementById("keyword");

        if (subject !== undefined) {
          subjectSelect.value = subject;
          updateSubtopicOptions(subject);
        }
        if (subtopic !== undefined) {
          subtopicSelect.value = subtopic;
        }
        if (keyword !== undefined) {
          keywordInput.value = keyword;
        }
        renderResults(filterQuestions());
      }

      function filterQuestions() {
        const keyword = document.getElementById("keyword").value.trim();
        const subject = document.getElementById("subjectSelect").value;
        const subtopic = document.getElementById("subtopicSelect").value;
        const examType = document.getElementById("examTypeSelect").value;
        const session = document.getElementById("sessionSelect").value;
        const sessionFromRaw = document.getElementById("sessionFrom").value;
        const sessionToRaw = document.getElementById("sessionTo").value;
        const sortSession = document.getElementById("sortSession").value;
        const needExplanation = document.getElementById("hasExplanation").checked;
        const needTags = document.getElementById("hasTags").checked;
        const needSubtopics = document.getElementById("hasSubtopics").checked;
        const showAnswered = document.getElementById("showAnswered").checked;
        const sessionFrom = sessionFromRaw ? Number(sessionFromRaw) : null;
        const sessionTo = sessionToRaw ? Number(sessionToRaw) : null;

        const terms = keyword
          .split(/[\s,]+/)
          .map(term => term.trim())
          .filter(Boolean);
        const tagTerms = [];
        const textTerms = [];
        const serialTerms = [];
        terms.forEach(term => {
          const lowered = normalizeAscii(term).toLowerCase();
          if (lowered.startsWith("#")) {
            tagTerms.push(lowered.slice(1));
            return;
          }
          const serial = normalizeSerialTerm(term);
          if (serial) {
            serialTerms.push(serial);
            return;
          }
          if (lowered) textTerms.push(lowered);
        });
        const setFromIndex = (index, key) => new Set((index[key] || []));

        let serialSet = null;
        if (subject) serialSet = setFromIndex(state.indexBySubject, subject);
        const subtopicFilter = subtopic;

        const filtered = state.questions.filter(q => {
          const effective = applyOverridesToQuestion(q);
          if (serialSet && !serialSet.has(effective.serial)) return false;
          if (examType && !effective.serial.startsWith(examType)) return false;
          if (session && String(effective.exam_session) !== session) return false;
          if (sessionFrom !== null && Number(effective.exam_session) < sessionFrom) return false;
          if (sessionTo !== null && Number(effective.exam_session) > sessionTo) return false;
          if (!showAnswered && hasAnswered(effective.serial)) return false;
          if (needExplanation && !(effective.explanation_latest || "").trim()) return false;
          if (needTags && !(effective.tags || []).length) return false;
          if (needSubtopics && !(effective.subtopics || []).length) return false;
          if (subtopicFilter && !(effective.subtopics || []).includes(subtopicFilter)) return false;
          if (serialTerms.length && !serialTerms.includes(effective.serial)) return false;
          if (!terms.length) return true;
          const hay = [
            effective.stem || "",
            (effective.choices || []).join(" "),
            effective.case_text || "",
            (effective.tags || []).join(" "),
            (effective.subtopics || []).join(" ")
          ].join(" ").toLowerCase();
          const tagMatch = tagTerms.every(tag => (effective.tags || []).join(" ").toLowerCase().includes(tag));
          const textMatch = textTerms.every(term => hay.includes(term));
          return tagMatch && textMatch;
        });
        const getStats = (q) => state.answerStatsBySerial[q.serial] || { count: 0, correct: 0 };
        const getRate = (q) => {
          const stats = getStats(q);
          return stats.count ? stats.correct / stats.count : 0;
        };
        if (sortSession === "asc") {
          filtered.sort((a, b) => {
            const sessionDiff = (a.exam_session || 0) - (b.exam_session || 0);
            if (sessionDiff !== 0) return sessionDiff;
            const orderA = state.orderIndexBySerial[a.serial] || 0;
            const orderB = state.orderIndexBySerial[b.serial] || 0;
            return orderA - orderB;
          });
        } else if (sortSession === "desc") {
          filtered.sort((a, b) => {
            const sessionDiff = (b.exam_session || 0) - (a.exam_session || 0);
            if (sessionDiff !== 0) return sessionDiff;
            const orderA = state.orderIndexBySerial[a.serial] || 0;
            const orderB = state.orderIndexBySerial[b.serial] || 0;
            return orderA - orderB;
          });
        } else if (sortSession === "count_desc") {
          filtered.sort((a, b) => getStats(b).count - getStats(a).count);
        } else if (sortSession === "count_asc") {
          filtered.sort((a, b) => getStats(a).count - getStats(b).count);
        } else if (sortSession === "correct_desc") {
          filtered.sort((a, b) => getStats(b).correct - getStats(a).correct);
        } else if (sortSession === "correct_asc") {
          filtered.sort((a, b) => getStats(a).correct - getStats(b).correct);
        } else if (sortSession === "rate_desc") {
          filtered.sort((a, b) => getRate(b) - getRate(a));
        } else if (sortSession === "rate_asc") {
          filtered.sort((a, b) => getRate(a) - getRate(b));
        }
        return filtered;
      }

      function renderResults(list) {
        const container = document.getElementById("results");
        const moreContainer = document.getElementById("resultsMore");
        container.innerHTML = "";
        moreContainer.innerHTML = "";
        const isTeacher = Boolean(state.teacherSession);
        const showAnswer = document.getElementById("toggleAnswer").checked;
        const showExplanation = document.getElementById("toggleExplanation").checked;
        document.getElementById("countInfo").textContent = `件数: ${list.length}`;
        const sortSession = document.getElementById("sortSession").value;
        const isStatSort = [
          "count_desc",
          "count_asc",
          "correct_desc",
          "correct_asc",
          "rate_desc",
          "rate_asc"
        ].includes(sortSession);

        function appendCard(q, target) {
          const card = document.createElement("div");
          card.className = "card";
        card.setAttribute("tabindex", "0");
          card.setAttribute("role", "group");
          card.setAttribute("aria-label", `問題 ${q.serial}`);
          if (showAnswer) {
            card.classList.add("show");
          }
          if (showExplanation) {
            card.classList.add("show-explanation");
          }

          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = `${q.serial} / ${q.subject} / 第${q.exam_session}回`;
          card.appendChild(meta);

          if (q.case_text) {
            const caseText = document.createElement("div");
            caseText.className = "case-text";
            caseText.textContent = q.case_text;
            card.appendChild(caseText);
          }

          const stem = document.createElement("div");
          stem.className = "stem";
          stem.textContent = q.stem || "";
          card.appendChild(stem);

          const ul = document.createElement("ol");
          ul.className = "choices";
          const nums = ["１", "２", "３", "４", "５", "６", "７", "８", "９"];
          const answered = getAnswered(q.serial);
          const correctIndices = getAnswerIndices(q);
          (q.choices || []).forEach((choice, idx) => {
            const li = document.createElement("li");
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "choice-btn";
            btn.textContent = choice;
            btn.setAttribute("aria-label", `選択肢${idx + 1} ${choice}`);
            if (answered) {
              btn.disabled = true;
              if (!q.answer_none && correctIndices.includes(idx + 1)) {
                btn.classList.add("correct");
              }
              if (q.answer_none && answered.selectedIndex === idx + 1) {
                btn.classList.add("correct");
              }
              if (answered.selectedIndex === idx + 1 && !answered.isCorrect) {
                btn.classList.add("incorrect");
              }
            }
            btn.addEventListener("click", () => {
              handleAnswerSelection(q, idx + 1, btn);
            });
            li.appendChild(btn);
            ul.appendChild(li);
          });
          card.appendChild(ul);

          const feedback = document.createElement("div");
          feedback.className = "choice-feedback";
          if (answered) {
            feedback.textContent = answered.isCorrect ? "正解" : "不正解";
          }
          card.appendChild(feedback);

          const tags = document.createElement("div");
          tags.className = "tagline";
          const tagsLabel = document.createElement("span");
          tagsLabel.className = "tag-label";
          tagsLabel.textContent = "タグ:";
          tags.appendChild(tagsLabel);
          const tagList = q.tags || [];
          if (!tagList.length) {
            const span = document.createElement("span");
            span.textContent = "(なし)";
            tags.appendChild(span);
          } else {
            tagList.forEach(tag => {
              const link = document.createElement("button");
              link.className = "chip-link";
              link.textContent = tag;
              link.setAttribute("aria-label", `タグ ${tag} で絞り込み`);
              link.addEventListener("click", () => {
                applyFilters({ keyword: `#${tag}` });
              });
              tags.appendChild(link);
            });
          }
          if (!isTeacher) {
            const tagDetails = document.createElement("details");
            tagDetails.className = "inline inline-details";
            const tagSummary = document.createElement("summary");
            tagSummary.className = "inline-summary";
            tagSummary.textContent = "タグ修正を提案";
            tagDetails.appendChild(tagSummary);
            const tagPanel = document.createElement("div");
            tagPanel.className = "edit-panel";
            const tagRemoveWrap = document.createElement("div");
            (q.tags || []).forEach(tag => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = tag;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + tag));
              tagRemoveWrap.appendChild(lbl);
            });
            tagPanel.appendChild(tagRemoveWrap);
            const tagAdd = document.createElement("input");
            tagAdd.type = "text";
            tagAdd.placeholder = "追加タグ（カンマ区切り）";
            tagPanel.appendChild(tagAdd);
            const tagNote = document.createElement("input");
            tagNote.type = "text";
            tagNote.placeholder = "コメント（必須）";
            tagPanel.appendChild(tagNote);
            const tagSubmit = document.createElement("button");
            tagSubmit.textContent = "提案を送信";
            tagSubmit.addEventListener("click", () => {
              const remove = Array.from(tagRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = tagAdd.value.split(",").map(t => t.trim()).filter(Boolean);
              if (!add.length && !remove.length) {
                alert("追加または削除を入力してください。");
                return;
              }
              submitGuestEditRequest(q.serial, "tag", { add, remove }, tagNote.value);
            });
            tagPanel.appendChild(tagSubmit);
            tagDetails.appendChild(tagPanel);
            tags.appendChild(tagDetails);
          }
          if (isTeacher) {
            const tagDetails = document.createElement("details");
            tagDetails.className = "inline inline-details";
            const tagSummary = document.createElement("summary");
            tagSummary.className = "inline-summary";
            tagSummary.textContent = "タグ編集";
            tagDetails.appendChild(tagSummary);
            const tagPanel = document.createElement("div");
            tagPanel.className = "edit-panel";
            const tagRemoveWrap = document.createElement("div");
            (q.tags || []).forEach(tag => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = tag;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + tag));
              tagRemoveWrap.appendChild(lbl);
            });
            tagPanel.appendChild(tagRemoveWrap);
            const tagAdd = document.createElement("input");
            tagAdd.type = "text";
            tagAdd.placeholder = "追加タグ（カンマ区切り）";
            tagPanel.appendChild(tagAdd);
            const tagNote = document.createElement("input");
            tagNote.type = "text";
            tagNote.placeholder = "コメント（任意）";
            tagPanel.appendChild(tagNote);
            const tagSubmit = document.createElement("button");
            tagSubmit.textContent = "タグを反映";
            tagSubmit.addEventListener("click", () => {
              const remove = Array.from(tagRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = tagAdd.value.split(",").map(t => t.trim()).filter(Boolean);
              applyTagsOverride(q, add, remove, tagNote.value);
            });
            tagPanel.appendChild(tagSubmit);
            tagDetails.appendChild(tagPanel);
            tags.appendChild(tagDetails);
            const tagProposals = buildProposalList(q, "tag");
            if (tagProposals) tags.appendChild(tagProposals);
          }
          card.appendChild(tags);

          const subs = document.createElement("div");
          subs.className = "tagline";
          const subsLabel = document.createElement("span");
          subsLabel.className = "tag-label";
          subsLabel.textContent = "小項目:";
          subs.appendChild(subsLabel);
          const subList = q.subtopics || [];
          if (!subList.length) {
            const span = document.createElement("span");
            span.textContent = "(なし)";
            subs.appendChild(span);
          } else {
            subList.forEach(sub => {
              const link = document.createElement("button");
              link.className = "chip-link";
              link.textContent = sub;
              link.setAttribute("aria-label", `小項目 ${sub} で絞り込み`);
              link.addEventListener("click", () => {
                applyFilters({ subject: q.subject, subtopic: sub });
              });
              subs.appendChild(link);
            });
          }
          if (!isTeacher) {
            const subDetails = document.createElement("details");
            subDetails.className = "inline inline-details";
            const subSummary = document.createElement("summary");
            subSummary.className = "inline-summary";
            subSummary.textContent = "小項目修正を提案";
            subDetails.appendChild(subSummary);
            const subPanel = document.createElement("div");
            subPanel.className = "edit-panel";
            const subRemoveWrap = document.createElement("div");
            (q.subtopics || []).forEach(name => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = name;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + name));
              subRemoveWrap.appendChild(lbl);
            });
            subPanel.appendChild(subRemoveWrap);
            const subSelect = document.createElement("select");
            subSelect.multiple = true;
            subSelect.style.width = "100%";
            const catalog = state.subtopicCatalog[q.subject] || [];
            catalog.forEach(name => {
              const opt = document.createElement("option");
              opt.value = name;
              opt.textContent = name;
              subSelect.appendChild(opt);
            });
            subPanel.appendChild(subSelect);
            const subNote = document.createElement("input");
            subNote.type = "text";
            subNote.placeholder = "コメント（必須）";
            subPanel.appendChild(subNote);
            const subSubmit = document.createElement("button");
            subSubmit.textContent = "提案を送信";
            subSubmit.addEventListener("click", () => {
              const remove = Array.from(subRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = Array.from(subSelect.selectedOptions).map(opt => opt.value);
              if (!add.length && !remove.length) {
                alert("追加または削除を入力してください。");
                return;
              }
              submitGuestEditRequest(q.serial, "subtopic", { add, remove }, subNote.value);
            });
            subPanel.appendChild(subSubmit);
            subDetails.appendChild(subPanel);
            subs.appendChild(subDetails);
          }
          if (isTeacher) {
            const subDetails = document.createElement("details");
            subDetails.className = "inline inline-details";
            const subSummary = document.createElement("summary");
            subSummary.className = "inline-summary";
            subSummary.textContent = "小項目編集";
            subDetails.appendChild(subSummary);
            const subPanel = document.createElement("div");
            subPanel.className = "edit-panel";
            const subRemoveWrap = document.createElement("div");
            (q.subtopics || []).forEach(name => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = name;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + name));
              subRemoveWrap.appendChild(lbl);
            });
            subPanel.appendChild(subRemoveWrap);
            const subSelect = document.createElement("select");
            subSelect.multiple = true;
            subSelect.style.width = "100%";
            const catalog = state.subtopicCatalog[q.subject] || [];
            catalog.forEach(name => {
              const opt = document.createElement("option");
              opt.value = name;
              opt.textContent = name;
              subSelect.appendChild(opt);
            });
            subPanel.appendChild(subSelect);
            const subNote = document.createElement("input");
            subNote.type = "text";
            subNote.placeholder = "コメント（任意）";
            subPanel.appendChild(subNote);
            const subSubmit = document.createElement("button");
            subSubmit.textContent = "小項目を反映";
            subSubmit.addEventListener("click", () => {
              const remove = Array.from(subRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = Array.from(subSelect.selectedOptions).map(opt => opt.value);
              applySubtopicsOverride(q, add, remove, subNote.value);
            });
            subPanel.appendChild(subSubmit);
            subDetails.appendChild(subPanel);
            subs.appendChild(subDetails);
            const subProposals = buildProposalList(q, "subtopic");
            if (subProposals) subs.appendChild(subProposals);
          }
          card.appendChild(subs);

          const answer = document.createElement("div");
          answer.className = "answer";
          const label = formatAnswerLabel(q);
          answer.textContent = label ? `正答: ${label}` : "正答: 未登録";
          card.appendChild(answer);

          const explanation = document.createElement("div");
          explanation.className = "explanation";
          const expText = q.explanation_latest || "";
          const expLabel = formatExplanationLabel(q.explanation_latest_source);
          const expHeader = document.createElement("div");
          expHeader.className = "explanation-header";
          const expTitle = document.createElement("span");
          expTitle.textContent = expText ? `解説${expLabel}:` : "解説: (未登録)";
          expHeader.appendChild(expTitle);
          if (!isTeacher) {
            if (q.explanations && q.explanations.length > 1) {
              const select = document.createElement("select");
              select.setAttribute("aria-label", "解説バージョンを選択");
              const label = document.createElement("option");
              label.value = "";
              label.textContent = "解説バージョン";
              select.appendChild(label);
              q.explanations.forEach(item => {
                const opt = document.createElement("option");
                opt.value = JSON.stringify({ body: item.body, source: item.source || "" });
                opt.textContent = `v${item.version}`;
                select.appendChild(opt);
              });
              select.addEventListener("change", () => {
                if (select.value) {
                  try {
                    const data = JSON.parse(select.value);
                    const label = formatExplanationLabel(data.source);
                    expTitle.textContent = `解説${label}:`;
                    expBody.textContent = data.body || "";
                  } catch (err) {
                    expTitle.textContent = "解説:";
                    expBody.textContent = select.value || "";
                  }
                } else {
                  expTitle.textContent = expText ? `解説${expLabel}:` : "解説: (未登録)";
                  expBody.textContent = expText || "";
                }
              });
              expHeader.appendChild(select);
            }
            const expDetails = document.createElement("details");
            expDetails.className = "inline inline-details";
            const expSummary = document.createElement("summary");
            expSummary.className = "inline-summary";
            expSummary.textContent = "解説修正を提案";
            expDetails.appendChild(expSummary);
            const expPanel = document.createElement("div");
            expPanel.className = "edit-panel";
            const expArea = document.createElement("textarea");
            expArea.rows = 4;
            expArea.value = expText || "";
            expPanel.appendChild(expArea);
            const expNote = document.createElement("input");
            expNote.type = "text";
            expNote.placeholder = "コメント（必須）";
            expPanel.appendChild(expNote);
            const expSubmit = document.createElement("button");
            expSubmit.textContent = "提案を送信";
            expSubmit.addEventListener("click", () => {
              if (!expArea.value.trim()) {
                alert("解説を入力してください。");
                return;
              }
              submitGuestEditRequest(
                q.serial,
                "explanation",
                { explanation: expArea.value },
                expNote.value
              );
            });
            expPanel.appendChild(expSubmit);
            expDetails.appendChild(expPanel);
            expHeader.appendChild(expDetails);
          }
          if (isTeacher) {
            const source = q.explanation_latest_source || "";
            const teacherLabel = formatExplanationLabel(source);
            expTitle.textContent = expText ? `解説${teacherLabel}:` : "解説: (未登録)";
            if (source === "llm_checked") {
              const expRevoke = document.createElement("button");
              expRevoke.textContent = "承認取消";
              expRevoke.addEventListener("click", () => {
                applyExplanationConfirm(q, "llm");
              });
              expHeader.appendChild(expRevoke);
            } else if (source !== "teacher" && source !== "human") {
              const expConfirm = document.createElement("button");
              expConfirm.textContent = "解説承認";
              expConfirm.addEventListener("click", () => {
                applyExplanationConfirm(q, "llm_checked");
              });
              expHeader.appendChild(expConfirm);
            }

            const expDetails = document.createElement("details");
            expDetails.className = "inline inline-details";
            const expSummary = document.createElement("summary");
            expSummary.className = "inline-summary";
            expSummary.textContent = "解説編集";
            expDetails.appendChild(expSummary);
            const expPanel = document.createElement("div");
            expPanel.className = "edit-panel";
            const expArea = document.createElement("textarea");
            expArea.rows = 4;
            expArea.value = expText || "";
            expPanel.appendChild(expArea);
            const expNote = document.createElement("input");
            expNote.type = "text";
            expNote.placeholder = "コメント（任意）";
            expPanel.appendChild(expNote);
            const expSubmit = document.createElement("button");
            expSubmit.textContent = "解説を反映";
            expSubmit.addEventListener("click", () => {
              applyExplanationEdit(q, expArea.value, expNote.value);
            });
            expPanel.appendChild(expSubmit);
            expDetails.appendChild(expPanel);
            expHeader.appendChild(expDetails);
            const expProposals = buildProposalList(q, "explanation");
            if (expProposals) explanation.appendChild(expProposals);
          }
          explanation.appendChild(expHeader);
          const expBody = document.createElement("div");
          expBody.className = "explanation-body";
          expBody.textContent = expText || "";
          explanation.appendChild(expBody);
          const stats =
            state.answerStatsBySerial[q.serial] ||
            (state.answerStatsLoaded.has("*") ? { count: 0, correct: 0 } : null);
          if (stats) {
            const statsEl = document.createElement("div");
            statsEl.className = "answer-stats";
            if (stats.count >= 5) {
              const rate = stats.count ? Math.round((stats.correct / stats.count) * 100) : 0;
              statsEl.textContent = `回答数: ${stats.count} / 正答数: ${stats.correct} / 正答率: ${rate}%`;
            } else {
              statsEl.textContent = `集計中（回答数: ${stats.count}）`;
            }
            explanation.appendChild(statsEl);
          }
          card.appendChild(explanation);

          const actions = document.createElement("div");
          actions.className = "card-actions";
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "この問題をコピー";
          copyBtn.setAttribute("aria-label", "この問題をクリップボードにコピー");
          copyBtn.addEventListener("click", () => {
            const mode = getCopyMode();
            const text = formatQuestionForCopy(q, mode);
            copyToClipboard(text);
          });
          actions.appendChild(copyBtn);
          card.appendChild(actions);

          target.appendChild(card);
        }

        const subset = list;
        let idx = 0;
        const batchSize = 20;
        const more = document.createElement("button");
        const updateLabel = () => {
          more.textContent = `さらに表示 (${idx}/${subset.length})`;
        };
        function renderBatch(batch) {
          const frag = document.createDocumentFragment();
          batch.forEach(item => {
            appendCard(applyOverridesToQuestion(item), frag);
          });
          container.appendChild(frag);
        }
        async function renderChunk() {
          const end = Math.min(idx + batchSize, subset.length);
          const batch = subset.slice(idx, end);
          idx = end;
          more.disabled = true;
          const statsLoaded = state.answerStatsLoaded.has("*");
          await ensureOverridesLoaded(batch.map(item => item.serial));
          if (isTeacher) {
            await ensureEditRequestsLoaded(batch.map(item => item.serial));
          }
          await ensureAnswerStatsLoaded(batch.map(item => item.serial));
          if (isStatSort && !statsLoaded && state.answerStatsLoaded.has("*")) {
            renderResults(filterQuestions());
            return;
          }
          renderBatch(batch);
          more.disabled = false;
          updateLabel();
          if (idx >= subset.length) {
            more.remove();
          }
        }

        renderChunk();
        if (idx < subset.length) {
          updateLabel();
          more.addEventListener("click", () => {
            renderChunk();
          });
          moreContainer.appendChild(more);
        }
      }

      function init() {
        loadAnsweredState();
        loadSubtopicCatalog();
        const updateInfo = document.getElementById("updateInfo");
        const updateMoreBtn = document.getElementById("updateMoreBtn");
        loadUserReadme();
        loadUpdateLog().then(() => {
          if (updateInfo && updateInfo.open) {
            renderUpdateLog(3);
          }
        });
        loadData().then(() => {
          populateSelect(
            document.getElementById("subjectSelect"),
            Object.keys(state.indexBySubject)
          );
          updateSubtopicOptions("");
          populateSelect(
            document.getElementById("sessionSelect"),
            Array.from(new Set(state.questions.map(q => String(q.exam_session))))
              .sort((a, b) => Number(a) - Number(b))
          );
          renderResults(filterQuestions());
        });

        initAuthUI();
        if (updateInfo) {
          updateInfo.addEventListener("toggle", () => {
            if (updateInfo.open) {
              renderUpdateLog(3);
            }
          });
        }
        if (updateMoreBtn) {
          updateMoreBtn.addEventListener("click", () => {
            renderUpdateLog(state.updateShown + 3);
          });
        }

        initHistoryPanel();
        initProposalPanel();

        document.getElementById("searchBtn").addEventListener("click", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("resetBtn").addEventListener("click", () => {
          document.getElementById("keyword").value = "";
          document.getElementById("subjectSelect").value = "";
          document.getElementById("examTypeSelect").value = "";
          document.getElementById("sessionSelect").value = "";
          document.getElementById("sessionFrom").value = "";
          document.getElementById("sessionTo").value = "";
          document.getElementById("sortSession").value = "desc";
          document.getElementById("showAnswered").checked = false;
          document.getElementById("hasExplanation").checked = false;
          document.getElementById("hasTags").checked = false;
          document.getElementById("hasSubtopics").checked = false;
          updateSubtopicOptions("");
          renderResults(filterQuestions());
        });
        document.getElementById("subjectSelect").addEventListener("change", (e) => {
          updateSubtopicOptions(e.target.value);
          renderResults(filterQuestions());
        });
        document.getElementById("subtopicSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("examTypeSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sessionSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sessionFrom").addEventListener("input", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sessionTo").addEventListener("input", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sortSession").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("showAnswered").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasExplanation").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasTags").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasSubtopics").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("toggleAnswer").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("toggleExplanation").addEventListener("change", () => {
          renderResults(filterQuestions());
        });

      document.getElementById("copyAllBtn").addEventListener("click", async () => {
        const list = filterQuestions();
        await ensureOverridesLoaded(list.map(item => item.serial));
        const header = buildFilterHeader();
        const mode = getCopyMode();
        const body = list.map(q => formatQuestionForCopy(applyOverridesToQuestion(q), mode)).join("\n\n");
        copyToClipboard(`${header}\n\n${body}`.trim());
      });

      document.getElementById("resetAnswersBtn").addEventListener("click", () => {
        if (!confirm("回答履歴をリセットしますか？")) {
          return;
        }
        state.answeredMap = {};
        localStorage.removeItem("answeredSerials");
        renderResults(filterQuestions());
      });

        document.getElementById("keyword").addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            renderResults(filterQuestions());
          }
        });

        document.addEventListener("keydown", (e) => {
          const active = document.activeElement;
          const isInput =
            active &&
            (active.tagName === "INPUT" ||
              active.tagName === "TEXTAREA" ||
              active.tagName === "SELECT");
          if (isInput && e.key !== "Escape") {
            return;
          }
          if (e.key === "/") {
            e.preventDefault();
            document.getElementById("keyword").focus();
          } else if (e.key === "s") {
            document.getElementById("subjectSelect").focus();
          } else if (e.key === "u") {
            document.getElementById("subtopicSelect").focus();
          } else if (e.key === "f") {
            renderResults(filterQuestions());
          } else if (e.key === "r") {
            document.getElementById("resetBtn").click();
          } else if (e.key === "a") {
            const toggle = document.getElementById("toggleAnswer");
            toggle.checked = !toggle.checked;
            renderResults(filterQuestions());
          } else if (e.key === "e") {
            const toggle = document.getElementById("toggleExplanation");
            toggle.checked = !toggle.checked;
            renderResults(filterQuestions());
          }
        });
      }

      init();

      function sendReport(serial, kind, button, comment) {
        const anonId = getAnonId();
        if (supabaseClient) {
          supabaseClient
            .from("feedback")
            .insert([{ serial, kind, anon_id: anonId, comment: comment }])
            .then(({ error }) => {
              if (error) {
                button.classList.remove("reported");
                console.warn("報告に失敗しました。", error);
                return;
              }
              button.classList.add("reported");
            });
          return;
        }
        fetch(
          `${API_BASE}/api/report?serial=${encodeURIComponent(serial)}&kind=${encodeURIComponent(kind)}&comment=${encodeURIComponent(comment || "")}`,
          { mode: "cors" }
        )
          .then(resp => resp.json())
          .then(data => {
            if (data.message && data.message.startsWith("報告しました")) {
              button.classList.add("reported");
            } else {
              button.classList.remove("reported");
              console.warn(data.message || "報告に失敗しました。");
            }
          })
          .catch(err => {
            button.classList.remove("reported");
            console.warn("報告に失敗しました。", err);
          });
      }

      function initAuthUI() {
        const status = document.getElementById("authStatus");
        const form = document.getElementById("authForm");
        const actions = document.getElementById("authActions");
        const message = document.getElementById("authMessage");
        const emailInput = document.getElementById("authEmail");
        const passwordInput = document.getElementById("authPassword");
        const loginBtn = document.getElementById("authLoginBtn");
        const logoutBtn = document.getElementById("authLogoutBtn");
        const toggleBtn = document.getElementById("authToggleBtn");
        const panel = document.getElementById("teacherAuth");
        const historyPanel = document.getElementById("historyPanel");

        if (!supabaseClient) {
          status.textContent = "Supabase未設定";
          form.hidden = true;
          panel.hidden = true;
          toggleBtn.hidden = true;
          if (historyPanel) historyPanel.hidden = true;
          return;
        }

        toggleBtn.addEventListener("click", () => {
          const next = panel.hidden;
          panel.hidden = !next ? true : false;
          toggleBtn.setAttribute("aria-expanded", next ? "true" : "false");
        });

        supabaseClient.auth.getSession().then(({ data }) => {
          updateAuthUI(data.session);
        });
        supabaseClient.auth.onAuthStateChange((_event, session) => {
          updateAuthUI(session);
        });

        loginBtn.addEventListener("click", async () => {
          const email = emailInput.value.trim();
          const password = passwordInput.value;
          message.textContent = "";
          if (!email || !password) {
            message.textContent = "メールとパスワードを入力してください。";
            return;
          }
          const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
          if (error || !data || !data.session) {
            message.textContent = "ログインに失敗しました。";
            return;
          }
          const user = data.session.user;
          if (!isTeacherUser(user)) {
            message.textContent = "教師権限がありません。";
            await supabaseClient.auth.signOut();
            return;
          }
          message.textContent = "ログインしました。";
        });

        const signupBtn = document.getElementById("signupBtn");
        const signupEmail = document.getElementById("signupEmail");
        const signupPassword = document.getElementById("signupPassword");
        const signupPasswordConfirm = document.getElementById("signupPasswordConfirm");
        const signupNote = document.getElementById("signupNote");
        if (signupBtn) {
          signupBtn.addEventListener("click", async () => {
            const email = signupEmail ? signupEmail.value.trim() : "";
            const password = signupPassword ? signupPassword.value : "";
            const passwordConfirm = signupPasswordConfirm ? signupPasswordConfirm.value : "";
            const note = signupNote ? signupNote.value.trim() : "";
            message.textContent = "";
            if (!email || !password) {
              message.textContent = "メールとパスワードを入力してください。";
              return;
            }
            if (password !== passwordConfirm) {
              message.textContent = "パスワードが一致しません。";
              return;
            }
            const { data, error } = await supabaseClient.auth.signUp({ email, password });
            if (error) {
              message.textContent = "申請に失敗しました。";
              return;
            }
            const user = data && data.user ? data.user : null;
            if (!user) {
              message.textContent = "申請を受け付けました。確認メール後に再度申請してください。";
              return;
            }
            const { error: insertError } = await supabaseClient
              .from("teacher_requests")
              .insert([
                {
                  user_id: user.id,
                  email: email,
                  note: note,
                  status: "pending"
                }
              ]);
            if (insertError) {
              message.textContent = "申請の登録に失敗しました。";
              return;
            }
            await supabaseClient.auth.signOut();
            message.textContent = "申請を受け付けました。承認後にログインできます。";
            if (signupPassword) signupPassword.value = "";
            if (signupPasswordConfirm) signupPasswordConfirm.value = "";
          });
        }

        logoutBtn.addEventListener("click", async () => {
          message.textContent = "";
          const { error } = await supabaseClient.auth.signOut();
          if (error) {
            message.textContent = "ログアウトに失敗しました。";
            return;
          }
          message.textContent = "ログアウトしました。";
        });

        function isTeacherUser(user) {
          return (user?.app_metadata?.role || user?.user_metadata?.role || "") === "teacher";
        }

      function updateAuthUI(session) {
        const user = session && session.user ? session.user : null;
        state.editRequestsBySerial = {};
        state.editRequestsLoaded = new Set();
        const proposalPanel = document.getElementById("proposalPanel");
        if (user && !isTeacherUser(user)) {
          state.teacherSession = null;
          status.textContent = "教師権限がありません。";
          form.hidden = false;
          actions.hidden = true;
          toggleBtn.textContent = "教師ログイン";
          toggleBtn.setAttribute("aria-label", "教師ログイン");
          message.textContent = "教師アカウントでログインしてください。";
          if (historyPanel) historyPanel.hidden = true;
          if (proposalPanel) proposalPanel.hidden = true;
          supabaseClient.auth.signOut();
          return;
        }
        state.teacherSession = user ? session : null;
        if (user) {
            if (state.teacherUserId !== user.id) {
              const answerToggle = document.getElementById("toggleAnswer");
              const explanationToggle = document.getElementById("toggleExplanation");
              if (answerToggle) answerToggle.checked = false;
              if (explanationToggle) explanationToggle.checked = true;
              state.teacherUserId = user.id;
            }
            status.textContent = `ログイン中: ${user.email}`;
            form.hidden = true;
            actions.hidden = false;
            toggleBtn.textContent = "教師ログイン（ログイン中）";
            toggleBtn.setAttribute("aria-label", "教師ログイン（ログイン中）");
            if (historyPanel) historyPanel.hidden = false;
            if (proposalPanel) proposalPanel.hidden = false;
          } else {
            state.teacherUserId = null;
            status.textContent = "未ログイン";
            form.hidden = false;
            actions.hidden = true;
            toggleBtn.textContent = "教師ログイン";
            toggleBtn.setAttribute("aria-label", "教師ログイン");
            if (historyPanel) historyPanel.hidden = true;
            if (proposalPanel) proposalPanel.hidden = true;
          }
          renderResults(filterQuestions());
        }
      }

      function submitEditRequest(serial, kind, payload, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const body = {
          serial: serial,
          kind: kind,
          payload: payload || {},
          note: note || "",
          status: "open",
          created_by: session.user.id,
          created_email: session.user.email
        };
        supabaseClient
          .from("edit_requests")
          .insert([body])
          .then(({ error }) => {
            if (error) {
              alert("送信に失敗しました。");
              return;
            }
            alert("編集提案を送信しました。");
          });
      }

      function submitGuestEditRequest(serial, kind, payload, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        if (!note || !note.trim()) {
          alert("コメントを入力してください。");
          return;
        }
        const body = {
          serial: serial,
          kind: kind,
          payload: payload || {},
          note: note.trim(),
          status: "open",
          created_by: getAnonId(),
          created_email: "guest"
        };
        supabaseClient
          .from("edit_requests")
          .insert([body])
          .then(({ error }) => {
            if (error) {
              alert("送信に失敗しました。");
              return;
            }
            alert("提案を送信しました。");
          });
      }

      function updateEditRequestStatus(id, status) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return Promise.resolve(false);
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return Promise.resolve(false);
        }
        return supabaseClient
          .from("edit_requests")
          .update({ status: status })
          .eq("id", id)
          .then(({ error }) => {
            if (error) {
              alert("更新に失敗しました。");
              return false;
            }
            Object.keys(state.editRequestsBySerial).forEach(serial => {
              state.editRequestsBySerial[serial] = (state.editRequestsBySerial[serial] || []).filter(
                item => item.id !== id
              );
            });
            renderResults(filterQuestions());
            return true;
          });
      }

      function applyTagsOverride(question, add, remove, note) {
        const before = { tags: question.tags || [] };
        const next = Array.from(
          new Set([...(question.tags || []), ...add].filter(tag => !remove.includes(tag)))
        );
        const after = { tags: next };
        return applyOverrideChange(question.serial, "tags", before, after, { tags: next }, note);
      }

      function applySubtopicsOverride(question, add, remove, note) {
        const before = { subtopics: question.subtopics || [] };
        const next = Array.from(
          new Set([...(question.subtopics || []), ...add].filter(name => !remove.includes(name)))
        );
        const after = { subtopics: next };
        return applyOverrideChange(question.serial, "subtopics", before, after, { subtopics: next }, note);
      }

      function applyExplanationConfirm(question, nextSource) {
        const current = question.explanation_latest_source || "";
        const normalized = nextSource || (current === "llm" || current === "ai" ? "llm_checked" : "llm_checked");
        const before = { explanation_source: current };
        const after = { explanation_source: normalized };
        return applyOverrideChange(
          question.serial,
          "explanation",
          before,
          after,
          { explanation_source: normalized }
        );
      }

      function applyExplanationEdit(question, body, note) {
        const before = {
          explanation: question.explanation_latest || "",
          explanation_source: question.explanation_latest_source || ""
        };
        const after = {
          explanation: body,
          explanation_source: "teacher"
        };
        return applyOverrideChange(
          question.serial,
          "explanation",
          before,
          after,
          { explanation: body, explanation_source: "teacher" },
          note
        );
      }

      function applyOverrideChange(serial, kind, beforeData, afterData, patch, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return Promise.resolve(false);
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return Promise.resolve(false);
        }
        const payload = {
          serial,
          updated_at: new Date().toISOString(),
          updated_by: session.user.id,
          synced_at: null,
          ...patch
        };
        const history = {
          serial,
          kind,
          before_data: beforeData,
          after_data: afterData,
          approved_by: session.user.id
        };
        return supabaseClient
          .from("question_overrides")
          .upsert(payload, { onConflict: "serial" })
          .then(({ error }) => {
            if (error) {
              alert(`反映に失敗しました: ${error.message}`);
              return false;
            }
            return supabaseClient
              .from("override_history")
              .insert([history])
              .then(({ error: historyError }) => {
                if (historyError) {
                  alert(`履歴の保存に失敗しました: ${historyError.message}`);
                  return false;
                }
                const existing = state.overridesBySerial[serial] || {};
                state.overridesBySerial[serial] = { ...existing, ...patch };
                state.overridesLoaded.add(serial);
                const base = state.questions.find(item => item.serial === serial);
                if (base) {
                  if (Object.prototype.hasOwnProperty.call(patch, "explanation")) {
                    base.explanation_latest = patch.explanation;
                  }
                  if (Object.prototype.hasOwnProperty.call(patch, "explanation_source")) {
                    base.explanation_latest_source = patch.explanation_source;
                  }
                  if (Object.prototype.hasOwnProperty.call(patch, "tags")) {
                    base.tags = patch.tags;
                  }
                  if (Object.prototype.hasOwnProperty.call(patch, "subtopics")) {
                    base.subtopics = patch.subtopics;
                  }
                }
                const scrollY = window.scrollY;
                renderResults(filterQuestions());
                requestAnimationFrame(() => {
                  window.scrollTo(0, scrollY);
                });
                return true;
              });
          });
      }

      async function ensureOverridesLoaded(serials) {
        if (!supabaseClient || !serials.length) return;
        const pending = serials.filter(serial => !state.overridesLoaded.has(serial));
        if (!pending.length) return;
        const chunkSize = 100;
        for (let i = 0; i < pending.length; i += chunkSize) {
          const chunk = pending.slice(i, i + chunkSize);
          const { data, error } = await supabaseClient
            .from("question_overrides")
            .select("serial, explanation, explanation_source, tags, subtopics")
            .in("serial", chunk)
            .is("synced_at", null);
          if (error) {
            console.warn("差分の取得に失敗しました。", error);
            return;
          }
          const map = {};
          (data || []).forEach(row => {
            map[row.serial] = row;
          });
          chunk.forEach(serial => {
            state.overridesBySerial[serial] = map[serial] || null;
            state.overridesLoaded.add(serial);
          });
          (data || []).forEach(row => {
            const base = state.questions.find(item => item.serial === row.serial);
            if (!base) return;
            if (row.explanation !== null && row.explanation !== undefined) {
              base.explanation_latest = row.explanation;
            }
            if (row.explanation_source !== null && row.explanation_source !== undefined) {
              base.explanation_latest_source = row.explanation_source;
            }
            if (row.tags !== null && row.tags !== undefined) {
              base.tags = row.tags;
            }
            if (row.subtopics !== null && row.subtopics !== undefined) {
              base.subtopics = row.subtopics;
            }
          });
        }
      }

      async function ensureEditRequestsLoaded(serials) {
        if (!supabaseClient || !serials.length) return;
        const session = state.teacherSession;
        if (!session || !session.user) return;
        const pending = serials.filter(serial => !state.editRequestsLoaded.has(serial));
        if (!pending.length) return;
        const chunkSize = 100;
        for (let i = 0; i < pending.length; i += chunkSize) {
          const chunk = pending.slice(i, i + chunkSize);
          const { data, error } = await supabaseClient
            .from("edit_requests")
            .select("id, serial, kind, payload, note, created_at, created_by, created_email, status")
            .in("serial", chunk)
            .eq("status", "open");
          if (error) {
            console.warn("編集提案の取得に失敗しました。", error);
            chunk.forEach(serial => {
              state.editRequestsBySerial[serial] = [];
              state.editRequestsLoaded.add(serial);
            });
            continue;
          }
          const map = {};
          (data || []).forEach(row => {
            if (!map[row.serial]) map[row.serial] = [];
            map[row.serial].push(row);
          });
          chunk.forEach(serial => {
            state.editRequestsBySerial[serial] = map[serial] || [];
            state.editRequestsLoaded.add(serial);
          });
        }
      }

      async function ensureAnswerStatsLoaded(serials) {
        if (!supabaseClient || !serials.length) return;
        if (state.answerStatsLoaded.has("*")) return;
        const pending = serials.filter(serial => !state.answerStatsLoaded.has(serial));
        if (!pending.length) return;
        const chunkSize = 100;
        for (let i = 0; i < pending.length; i += chunkSize) {
          const chunk = pending.slice(i, i + chunkSize);
          const { data, error } = await supabaseClient
            .from("answers")
            .select("serial, is_correct");
          if (error) {
            console.warn("回答集計の取得に失敗しました。", error);
            chunk.forEach(serial => {
              state.answerStatsBySerial[serial] = { count: 0, correct: 0 };
              state.answerStatsLoaded.add(serial);
            });
            continue;
          }
          const stats = {};
          (data || []).forEach(row => {
            if (!stats[row.serial]) {
              stats[row.serial] = { count: 0, correct: 0 };
            }
            stats[row.serial].count += 1;
            if (row.is_correct) {
              stats[row.serial].correct += 1;
            }
          });
          Object.keys(stats).forEach(serial => {
            state.answerStatsBySerial[serial] = stats[serial];
          });
          chunk.forEach(serial => {
            if (!state.answerStatsBySerial[serial]) {
              state.answerStatsBySerial[serial] = { count: 0, correct: 0 };
            }
            state.answerStatsLoaded.add(serial);
          });
          state.answerStatsLoaded.add("*");
        }
      }

      function applyOverridesToQuestion(q) {
        const override = state.overridesBySerial[q.serial];
        if (!override) return q;
        const merged = { ...q };
        if (override.explanation !== undefined && override.explanation !== null) {
          merged.explanation_latest = override.explanation;
          merged.explanation_latest_source =
            override.explanation_source || merged.explanation_latest_source;
        }
        if (override.tags !== undefined && override.tags !== null) {
          merged.tags = override.tags;
        }
        if (override.subtopics !== undefined && override.subtopics !== null) {
          merged.subtopics = override.subtopics;
        }
        return merged;
      }

      function getOpenEditRequests(serial, kind) {
        const list = state.editRequestsBySerial[serial] || [];
        return list.filter(item => item.kind === kind);
      }

      function buildProposalList(question, kind) {
        const items = getOpenEditRequests(question.serial, kind);
        if (!items.length) return null;
        const wrap = document.createElement("div");
        wrap.className = "proposal-list";
        const title = document.createElement("div");
        title.textContent = "提案";
        wrap.appendChild(title);

        items.forEach(item => {
          const entry = document.createElement("div");
          entry.className = "proposal-item";
          const meta = document.createElement("div");
          const when = item.created_at ? new Date(item.created_at).toLocaleString() : "";
          meta.textContent = when ? `日時: ${when}` : "日時: (不明)";
          entry.appendChild(meta);

          const payload = item.payload || {};
          if (kind === "tag" || kind === "subtopic") {
            const add = Array.isArray(payload.add) ? payload.add : [];
            const remove = Array.isArray(payload.remove) ? payload.remove : [];
            const addLine = document.createElement("div");
            const addLabel = document.createElement("span");
            addLabel.className = "proposal-label";
            addLabel.textContent = "追加:";
            addLine.appendChild(addLabel);
            addLine.appendChild(document.createTextNode(add.join(", ") || "(なし)"));
            entry.appendChild(addLine);
            const removeLine = document.createElement("div");
            const removeLabel = document.createElement("span");
            removeLabel.className = "proposal-label";
            removeLabel.textContent = "削除:";
            removeLine.appendChild(removeLabel);
            removeLine.appendChild(document.createTextNode(remove.join(", ") || "(なし)"));
            entry.appendChild(removeLine);
          }
          if (kind === "explanation") {
            const body = payload.explanation || payload.body || "";
            const bodyEl = document.createElement("div");
            bodyEl.textContent = body;
            entry.appendChild(bodyEl);
          }

          if (item.note) {
            const note = document.createElement("div");
            const noteLabel = document.createElement("span");
            noteLabel.className = "proposal-label";
            noteLabel.textContent = "コメント:";
            note.appendChild(noteLabel);
            note.appendChild(document.createTextNode(item.note));
            entry.appendChild(note);
          }

          const actions = document.createElement("div");
          actions.className = "proposal-actions";
          const applyBtn = document.createElement("button");
          applyBtn.textContent = "提案を反映";
          applyBtn.addEventListener("click", () => {
            if (kind === "tag") {
              const add = Array.isArray(payload.add) ? payload.add : [];
              const remove = Array.isArray(payload.remove) ? payload.remove : [];
              applyTagsOverride(question, add, remove, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
              return;
            }
            if (kind === "subtopic") {
              const add = Array.isArray(payload.add) ? payload.add : [];
              const remove = Array.isArray(payload.remove) ? payload.remove : [];
              applySubtopicsOverride(question, add, remove, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
              return;
            }
            if (kind === "explanation") {
              const body = payload.explanation || payload.body || "";
              if (!body.trim()) {
                alert("提案された解説が空です。");
                return;
              }
              applyExplanationEdit(question, body, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
            }
          });
          actions.appendChild(applyBtn);
          const rejectBtn = document.createElement("button");
          rejectBtn.textContent = "提案を却下";
          rejectBtn.addEventListener("click", () => {
            updateEditRequestStatus(item.id, "rejected");
          });
          actions.appendChild(rejectBtn);
          entry.appendChild(actions);
          wrap.appendChild(entry);
        });
        return wrap;
      }

      function initHistoryPanel() {
        const fetchBtn = document.getElementById("historyFetchBtn");
        if (!fetchBtn) return;
        fetchBtn.addEventListener("click", () => {
          fetchHistory();
        });
      }

      function initProposalPanel() {
        const fetchBtn = document.getElementById("proposalFetchBtn");
        if (!fetchBtn) return;
        fetchBtn.addEventListener("click", () => {
          fetchProposals();
        });
      }

      async function fetchHistory() {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const serialInput = document.getElementById("historySerial");
        const kindSelect = document.getElementById("historyKind");
        const serial = serialInput ? serialInput.value.trim() : "";
        const kind = kindSelect ? kindSelect.value : "";
        let query = supabaseClient
          .from("override_history")
          .select("id, serial, kind, before_data, after_data, created_at")
          .order("created_at", { ascending: false })
          .limit(50);
        if (serial) {
          query = query.eq("serial", serial);
        }
        if (kind) {
          query = query.eq("kind", kind);
        }
        const { data, error } = await query;
        if (error) {
          alert("履歴の取得に失敗しました。");
          return;
        }
        renderHistoryList(data || []);
      }

      async function fetchProposals() {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const serialInput = document.getElementById("proposalSerial");
        const statusSelect = document.getElementById("proposalStatus");
        const serial = serialInput ? serialInput.value.trim() : "";
        const status = statusSelect ? statusSelect.value : "open";
        let query = supabaseClient
          .from("edit_requests")
          .select("id, serial, kind, payload, note, created_at, status, created_email, created_by")
          .order("created_at", { ascending: false })
          .limit(200);
        if (serial) {
          query = query.eq("serial", serial);
        }
        if (status) {
          query = query.eq("status", status);
        }
        const { data, error } = await query;
        if (error) {
          alert("提案の取得に失敗しました。");
          return;
        }
        renderProposalList(data || []);
      }

      function renderHistoryList(items) {
        const list = document.getElementById("historyList");
        const empty = document.getElementById("historyEmpty");
        if (!list || !empty) return;
        list.innerHTML = "";
        if (!items.length) {
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        items.forEach(item => {
          const wrap = document.createElement("div");
          wrap.className = "history-item";
          const meta = document.createElement("div");
          meta.className = "history-meta";
          const when = item.created_at ? new Date(item.created_at).toLocaleString() : "";
          meta.textContent = `${item.serial} / ${kindLabel(item.kind)} / ${when}`;
          wrap.appendChild(meta);
          const body = document.createElement("div");
          body.className = "history-body";
          body.textContent = formatHistoryBody(item);
          wrap.appendChild(body);
          const rollback = document.createElement("button");
          rollback.type = "button";
          rollback.textContent = "この版に戻す";
          rollback.addEventListener("click", () => {
            applyHistoryRollback(item);
          });
          wrap.appendChild(rollback);
          list.appendChild(wrap);
        });
      }

      function renderProposalList(items) {
        const list = document.getElementById("proposalList");
        const empty = document.getElementById("proposalEmpty");
        if (!list || !empty) return;
        list.innerHTML = "";
        if (!items.length) {
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        items.forEach(item => {
          const row = document.createElement("div");
          row.className = "proposal-row";
          const meta = document.createElement("div");
          meta.className = "proposal-meta";
          const when = item.created_at ? new Date(item.created_at).toLocaleString() : "";
          meta.textContent = `${item.serial} / ${kindLabelEdit(item.kind)} / ${when} / ${item.status || ""}`;
          row.appendChild(meta);
          const body = document.createElement("div");
          body.textContent = formatProposalSummary(item);
          row.appendChild(body);
          const actions = document.createElement("div");
          actions.className = "proposal-actions";
          const openBtn = document.createElement("button");
          openBtn.type = "button";
          openBtn.textContent = "この問題を開く";
          openBtn.addEventListener("click", () => {
            applyFilters({ keyword: item.serial });
          });
          actions.appendChild(openBtn);
          row.appendChild(actions);
          list.appendChild(row);
        });
      }

      function kindLabel(kind) {
        if (kind === "explanation") return "解説";
        if (kind === "tags") return "タグ";
        if (kind === "subtopics") return "小項目";
        return kind || "";
      }

      function kindLabelEdit(kind) {
        if (kind === "explanation") return "解説";
        if (kind === "tag") return "タグ";
        if (kind === "subtopic") return "小項目";
        if (kind === "tags") return "タグ";
        if (kind === "subtopics") return "小項目";
        return kind || "";
      }

      function formatProposalSummary(item) {
        const payload = item.payload || {};
        if (item.kind === "tag" || item.kind === "subtopic") {
          const add = Array.isArray(payload.add) ? payload.add : [];
          const remove = Array.isArray(payload.remove) ? payload.remove : [];
          return `追加: ${add.join(", ") || "(なし)"} / 削除: ${remove.join(", ") || "(なし)"} / コメント: ${item.note || ""}`;
        }
        if (item.kind === "explanation") {
          const body = payload.explanation || payload.body || "";
          return `解説: ${truncateText(body)} / コメント: ${item.note || ""}`;
        }
        return item.note || "";
      }

      function formatHistoryBody(item) {
        const before = item.before_data || {};
        const after = item.after_data || {};
        if (item.kind === "explanation") {
          const beforeText = truncateText(before.explanation || "");
          const afterText = truncateText(after.explanation || "");
          const beforeLabel = formatExplanationLabel(before.explanation_source || "");
          const afterLabel = formatExplanationLabel(after.explanation_source || "");
          if (beforeText || afterText) {
            return `変更前${beforeLabel}: ${beforeText}\n変更後${afterLabel}: ${afterText}`;
          }
          return `変更前: ${before.explanation_source || "(空)"}\n変更後: ${after.explanation_source || "(空)"}`;
        }
        if (item.kind === "tags") {
          return `変更前: ${(before.tags || []).join(", ")}\n変更後: ${(after.tags || []).join(", ")}`;
        }
        if (item.kind === "subtopics") {
          return `変更前: ${(before.subtopics || []).join(", ")}\n変更後: ${(after.subtopics || []).join(", ")}`;
        }
        return JSON.stringify(item.after_data || {});
      }

      function truncateText(text) {
        if (!text) return "";
        return text.length > 160 ? `${text.slice(0, 160)}…` : text;
      }

      function applyHistoryRollback(item) {
        if (!confirm("この版に戻しますか？")) return;
        const base = state.questions.find(q => q.serial === item.serial);
        const current = base ? applyOverridesToQuestion(base) : null;
        if (!current) {
          alert("対象の問題が見つかりません。");
          return;
        }
        if (item.kind === "tags") {
          const before = { tags: current.tags || [] };
          const next = (item.before_data && item.before_data.tags) || [];
          const after = { tags: next };
          applyOverrideChange(item.serial, "tags", before, after, { tags: next }, "rollback");
          return;
        }
        if (item.kind === "subtopics") {
          const before = { subtopics: current.subtopics || [] };
          const next = (item.before_data && item.before_data.subtopics) || [];
          const after = { subtopics: next };
          applyOverrideChange(item.serial, "subtopics", before, after, { subtopics: next }, "rollback");
          return;
        }
        if (item.kind === "explanation") {
          const before = {
            explanation: current.explanation_latest || "",
            explanation_source: current.explanation_latest_source || ""
          };
          const nextBody = item.before_data ? item.before_data.explanation : "";
          const nextSource = item.before_data ? item.before_data.explanation_source : "";
          const after = {
            explanation: nextBody || "",
            explanation_source: nextSource || ""
          };
          const patch = {
            explanation: after.explanation,
            explanation_source: after.explanation_source
          };
          applyOverrideChange(item.serial, "explanation", before, after, patch, "rollback");
        }
      }

      function formatExplanationLabel(source) {
        if (!source) return "";
        if (source === "llm_checked") return "（AI承認済み）";
        if (source === "human" || source === "teacher") return "（教師編集）";
        if (source === "llm" || source === "ai") return "（AI）";
        return "（" + source + "）";
      }

      function getAnswerIndices(question) {
        if (!question) return [];
        const indices = Array.isArray(question.answer_indices)
          ? question.answer_indices.map(Number)
          : [];
        if (!indices.length && question.answer_index) {
          indices.push(Number(question.answer_index));
        }
        return indices.filter(n => Number.isFinite(n));
      }

      function isAnswerCorrect(question, selectedIndex) {
        if (!question) return false;
        if (question.answer_none) return true;
        const indices = getAnswerIndices(question);
        if (!indices.length) return false;
        return indices.includes(Number(selectedIndex));
      }

      function formatAnswerLabel(question) {
        if (!question) return "";
        if (question.answer_none) return "なし";
        const indices = getAnswerIndices(question);
        if (!indices.length) return "";
        return indices.join("・");
      }

      function buildReportRequest(serial, kind, label) {
        const panelId = `report-${serial}-${kind}`.replace(/[^a-zA-Z0-9_-]/g, "-");
        const button = document.createElement("button");
        button.className = "request-btn";
        button.textContent = label;
        button.setAttribute("aria-label", `${label}を送信`);
        button.setAttribute("aria-expanded", "false");
        button.setAttribute("aria-controls", panelId);

        const panel = document.createElement("div");
        panel.className = "request-panel";
        panel.hidden = true;
        panel.id = panelId;

        const textarea = document.createElement("textarea");
        textarea.rows = 3;
        textarea.placeholder = "修正内容のコメント（必須）";
        textarea.setAttribute("aria-label", `${label}のコメント`);

        const error = document.createElement("div");
        error.className = "note";
        error.textContent = "コメントを入力してください。";
        error.hidden = true;

        const submit = document.createElement("button");
        submit.textContent = "送信";

        button.addEventListener("click", () => {
          panel.hidden = !panel.hidden;
          if (!panel.hidden) {
            textarea.focus();
          }
          button.setAttribute("aria-expanded", panel.hidden ? "false" : "true");
        });

        submit.addEventListener("click", () => {
          const comment = textarea.value.trim();
          if (!comment) {
            error.hidden = false;
            textarea.setAttribute("aria-invalid", "true");
            return;
          }
          error.hidden = true;
          textarea.removeAttribute("aria-invalid");
          sendReport(serial, kind, button, comment);
          textarea.value = "";
          panel.hidden = true;
          button.setAttribute("aria-expanded", "false");
        });

        panel.appendChild(textarea);
        panel.appendChild(error);
        panel.appendChild(submit);

        return { button, panel };
      }

      function handleAnswerSelection(question, selectedIndex, button) {
        if (hasAnswered(question.serial)) {
          return;
        }
        const correctIndices = getAnswerIndices(question);
        const isCorrect = isAnswerCorrect(question, Number(selectedIndex));
        const buttons = button.closest("ol")?.querySelectorAll(".choice-btn") || [];
        buttons.forEach((btn, idx) => {
          btn.disabled = true;
          btn.classList.remove("selected", "correct", "incorrect");
          if (!question.answer_none && correctIndices.includes(idx + 1)) {
            btn.classList.add("correct");
          }
        });
        if (question.answer_none && isCorrect) {
          button.classList.add("correct");
        } else if (!isCorrect) {
          button.classList.add("incorrect");
        }
        const feedback = button.closest(".card")?.querySelector(".choice-feedback");
        if (feedback) {
          feedback.textContent = isCorrect ? "正解" : "不正解";
        }
        const card = button.closest(".card");
        if (card) {
          card.classList.add("show-explanation");
        }
        markAnswered(question.serial, selectedIndex, isCorrect);
        const anonId = getAnonId();
        if (supabaseClient) {
          supabaseClient
            .from("answers")
            .insert([
              {
                serial: question.serial,
                is_correct: isCorrect,
                selected_index: selectedIndex,
                anon_id: anonId
              }
            ])
            .then(({ error }) => {
              if (error) {
                console.warn("回答の記録に失敗しました。", error);
              }
            });
        }
      }

      function hasAnswered(serial) {
        return Boolean(state.answeredMap[serial]);
      }

      function getAnswered(serial) {
        return state.answeredMap[serial] || null;
      }

      function markAnswered(serial, selectedIndex, isCorrect) {
        state.answeredMap[serial] = {
          selectedIndex: Number(selectedIndex),
          isCorrect: Boolean(isCorrect)
        };
        saveAnsweredState();
      }

      function loadAnsweredState() {
        const key = "answeredSerials";
        const raw = localStorage.getItem(key);
        if (!raw) return;
        try {
          const map = JSON.parse(raw);
          if (map && typeof map === "object") {
            Object.keys(map).forEach(serial => {
              state.answeredMap[serial] = map[serial];
            });
          }
        } catch (err) {
          localStorage.removeItem(key);
        }
      }

      function saveAnsweredState() {
        const key = "answeredSerials";
        localStorage.setItem(key, JSON.stringify(state.answeredMap));
      }

      function getAnonId() {
        const key = "anonId";
        let id = localStorage.getItem(key);
        if (id) return id;
        if (crypto && crypto.randomUUID) {
          id = crypto.randomUUID();
        } else {
          id = `${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
        }
        localStorage.setItem(key, id);
        return id;
      }

      function buildFilterHeader() {
        const keyword = document.getElementById("keyword").value.trim();
        const subject = document.getElementById("subjectSelect").value;
        const subtopic = document.getElementById("subtopicSelect").value;
        const examType = document.getElementById("examTypeSelect").value;
        const session = document.getElementById("sessionSelect").value;
        const sessionFrom = document.getElementById("sessionFrom").value;
        const sessionTo = document.getElementById("sessionTo").value;
        const sortSession = document.getElementById("sortSession").value;
        const showAnswered = document.getElementById("showAnswered").checked;
        const parts = [];
        if (keyword) parts.push(`キーワード: ${keyword}`);
        if (subject) parts.push(`科目: ${subject}`);
        if (subtopic) parts.push(`小項目: ${subtopic}`);
        if (examType) parts.push(`種別: ${examType}`);
        if (session) parts.push(`回数: ${session}`);
        if (sessionFrom || sessionTo) {
          const fromLabel = sessionFrom ? `${sessionFrom}回` : "";
          const toLabel = sessionTo ? `${sessionTo}回` : "";
          const range = [fromLabel, toLabel].filter(Boolean).join("〜");
          parts.push(`回数範囲: ${range || "指定なし"}`);
        }
        if (sortSession) {
          const sortLabels = {
            asc: "古い順",
            desc: "新しい順",
            count_desc: "回答数が多い順",
            count_asc: "回答数が少ない順",
            correct_desc: "正答数が多い順",
            correct_asc: "正答数が少ない順",
            rate_desc: "正答率が高い順",
            rate_asc: "正答率が低い順"
          };
          const label = sortLabels[sortSession] || "新しい順";
          parts.push(`並び替え: ${label}`);
        }
        if (showAnswered) parts.push("回答済みを表示");
        return parts.length ? `検索条件: ${parts.join(" / ")}` : "検索条件: なし";
      }

      function getCopyMode() {
        const showAnswer = document.getElementById("toggleAnswer").checked;
        const showExplanation = document.getElementById("toggleExplanation").checked;
        return {
          showAnswer: showAnswer || showExplanation,
          showExplanation: showExplanation
        };
      }

      function formatQuestionForCopy(q, mode) {
        const showAnswer = mode && mode.showAnswer;
        const showExplanation = mode && mode.showExplanation;
        const lines = [];
        if (q.case_text) {
          lines.push(q.case_text);
        }
        lines.push(`${q.serial}　${q.stem || ""}`);
        const choices = q.choices || [];
        const nums = ["１", "２", "３", "４", "５", "６", "７", "８", "９"];
        choices.forEach((choice, idx) => {
          const n = nums[idx] || String(idx + 1);
          lines.push(`${n}．${choice}`);
        });
        if (showAnswer) {
          lines.push("　");
          let ansLabel = "";
          if (q.answer_none) {
            ansLabel = "なし";
          } else {
            const indices = getAnswerIndices(q);
            if (indices.length) {
              ansLabel = indices
                .map(idx => nums[idx - 1] || String(idx))
                .join("・");
            }
          }
          const ans = ansLabel ? `解答　${ansLabel}` : "解答　";
          lines.push(ans);
          if (showExplanation) {
            const exp = q.explanation_latest || "";
            if (exp) {
              lines.push("解説");
              lines.push(exp);
            }
          }
        }
        return lines.join("\n");
      }

      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text);
          return;
        }
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        textarea.remove();
      }
    </script>
  </body>
</html>
