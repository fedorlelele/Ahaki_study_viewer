<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ahaki Study Viewer</title>
    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "e88f0886e93c42adae0ff3dd06807843"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->
    <style>
      :root {
        --bg-1: #ffffff;
        --bg-2: #f1f5f9;
        --ink: #111111;
        --muted: #2b2b2b;
        --accent: #0b5cab;
        --card: #ffffff;
        --line: #4a4a4a;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
        color: var(--ink);
        background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
        min-height: 100vh;
      }
      header {
        padding: 28px 24px 10px;
      }
      .header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
      }
      h1 {
        margin: 0;
        font-size: clamp(24px, 4vw, 36px);
        letter-spacing: 0.5px;
      }
      .subtitle {
        color: var(--muted);
        margin-top: 6px;
        font-size: 14px;
      }
      .controls {
        display: grid;
        grid-template-columns: 1.6fr 1fr 1fr 1fr 1fr auto auto;
        gap: 10px;
        padding: 14px 24px 20px;
      }
      .controls input,
      .controls select,
      .controls button {
        padding: 10px 12px;
        border: 2px solid var(--line);
        border-radius: 10px;
        background: #fff;
        font-size: 14px;
      }
      .controls button {
        background: var(--accent);
        color: #fff;
        border: none;
        cursor: pointer;
      }
      .toolbar button {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .toolbar select {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .toolbar {
        padding: 0 24px 18px;
        display: flex;
        gap: 16px;
        align-items: center;
        color: var(--muted);
        font-size: 13px;
      }
      .toolbar.main {
        flex-wrap: wrap;
        gap: 10px;
      }
      .toolbar .auth-panel {
        margin-top: 0;
      }
      .results {
        padding: 0 24px 40px;
        display: grid;
        gap: 14px;
      }
      .card {
        background: var(--card);
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 16px 18px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        animation: fadeIn 250ms ease-in;
      }
      .meta {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        color: var(--muted);
        font-size: 12px;
      }
      .stem {
        margin: 10px 0 8px;
        font-size: 16px;
      }
      .case-text {
        margin: 10px 0 6px;
        padding: 8px 10px;
        background: #fff7e6;
        border-left: 4px solid #b67b0b;
        font-size: 13px;
        white-space: pre-wrap;
      }
      .choices {
        padding-left: 18px;
        margin: 6px 0;
      }
      .choice-btn {
        display: inline-block;
        width: 100%;
        text-align: left;
        border: none;
        background: transparent;
        padding: 4px 0;
        font-size: 14px;
        color: var(--ink);
        cursor: pointer;
      }
      .choice-btn:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }
      .choice-btn.selected {
        background: #e6f0ff;
        border-radius: 6px;
      }
      .choice-btn.correct {
        background: #e6f7ed;
        color: #0b5c2b;
        border-radius: 6px;
      }
      .choice-btn.incorrect {
        background: #ffe7ea;
        color: #7a0015;
        border-radius: 6px;
      }
      .choice-feedback {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      .tagline {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
      }
      .tag-label {
        font-weight: 600;
      }
      .chip-link {
        display: inline-block;
        margin: 2px 6px 0 0;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #fff;
        color: var(--muted);
        font-size: 12px;
        text-decoration: none;
        cursor: pointer;
      }
      .chip-link:hover {
        color: var(--ink);
        border-color: var(--accent);
      }
      .report-btn.reported {
        background: #ffe7ea;
        border-color: #b00020;
        color: #7a0015;
      }
      .answer {
        margin-top: 10px;
        padding: 8px 10px;
        border-left: 4px solid var(--accent);
        background: #e6f0ff;
        font-size: 13px;
        display: none;
      }
      .explanation {
        margin-top: 8px;
        padding: 8px 10px;
        border-left: 4px solid #0b7a5c;
        background: #e8f7f2;
        font-size: 13px;
        white-space: pre-wrap;
        display: none;
      }
      .card-actions {
        margin-top: 10px;
      }
      .note {
        color: var(--muted);
        font-size: 12px;
      }
      .update-list {
        margin: 6px 0 8px;
        padding-left: 18px;
        font-size: 12px;
      }
      .update-list li {
        margin: 4px 0;
      }
      .user-readme {
        margin: 6px 0;
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
        white-space: pre-wrap;
      }
      details.inline {
        margin-top: 8px;
      }
      details.inline > summary {
        cursor: pointer;
        font-size: 12px;
        color: var(--muted);
      }
      details.inline > summary.inline-summary {
        list-style: none;
        display: inline-block;
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
        color: var(--ink);
      }
      details.inline > summary.inline-summary::-webkit-details-marker {
        display: none;
      }
      .edit-panel {
        margin-top: 6px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
      }
      .edit-panel input,
      .edit-panel select,
      .edit-panel textarea,
      .edit-panel button {
        margin-top: 6px;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid var(--line);
        font-size: 12px;
      }
      .edit-panel textarea {
        width: 100%;
      }
      .explanation-header {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .explanation-body {
        margin-top: 6px;
        white-space: pre-wrap;
      }
      .inline-details[open] {
        flex-basis: 100%;
      }
      .inline-details[open] .edit-panel {
        width: 100%;
      }
      .auth-panel {
        margin-top: 8px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
      }
      .auth-panel input {
        width: 220px;
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        margin-right: 6px;
      }
      .history-panel {
        margin-top: 10px;
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 13px;
      }
      .history-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .history-controls input,
      .history-controls select,
      .history-controls button {
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        background: #fff;
        font-size: 12px;
      }
      .history-list {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }
      .history-item {
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px 10px;
        background: #f8fafc;
      }
      .history-meta {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      .history-body {
        font-size: 13px;
        white-space: pre-wrap;
      }
      .history-item button {
        margin-top: 6px;
        padding: 4px 8px;
        font-size: 12px;
      }
      .auth-panel .note {
        margin-top: 6px;
        color: var(--muted);
        font-size: 11px;
      }
      .auth-toggle {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .auth-container {
        padding: 0 24px 12px;
      }
      .auth-panel[hidden] {
        display: none;
      }
      .card-actions button,
      .card-actions select {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .request-btn {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--accent);
        background: #fff;
        color: var(--accent);
        cursor: pointer;
        font-size: 12px;
      }
      .request-btn.reported {
        background: #ffe7ea;
        border-color: #b00020;
        color: #7a0015;
      }
      .request-panel {
        margin-top: 6px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
        flex-basis: 100%;
        width: 100%;
      }
      .request-panel textarea,
      .request-panel button {
        margin-top: 6px;
        font-size: 12px;
      }
      .request-panel textarea {
        width: 100%;
        min-height: 96px;
        resize: vertical;
      }
      .show .answer { display: block; }
      .show-explanation .answer { display: block; }
      .show-explanation .explanation { display: block; }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(6px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @media (max-width: 900px) {
        .controls {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-row">
        <h1>Ahaki Study Viewer</h1>
        <button id="authToggleBtn" class="auth-toggle" aria-expanded="false">教師ログイン</button>
      </div>
      <div class="subtitle">検索・絞り込み・学習用の簡易ビュー</div>
      <div class="subtitle"><a href="./simple.html">かんたんビューを開く</a></div>
      <details class="inline" id="updateInfo">
        <summary>更新情報</summary>
        <div class="card-actions">
          <ul class="update-list" id="updateList"></ul>
          <button id="updateMoreBtn" type="button">さらに表示</button>
          <div class="note" id="updateEmpty" hidden>更新情報はありません。</div>
        </div>
      </details>
      <details class="inline" id="userReadme">
        <summary>利用ガイド</summary>
        <div class="card-actions">
          <pre class="user-readme" id="userReadmeText">読み込み中...</pre>
        </div>
      </details>
      <details class="inline" id="historyPanel" hidden>
        <summary>編集履歴</summary>
        <div class="history-panel">
          <div class="history-controls">
            <input id="historySerial" type="text" placeholder="シリアル (例: A01-001)" />
            <select id="historyKind">
              <option value="">すべて</option>
              <option value="explanation">解説</option>
              <option value="tags">タグ</option>
              <option value="subtopics">小項目</option>
            </select>
            <button id="historyFetchBtn" type="button">履歴を取得</button>
          </div>
          <div class="history-list" id="historyList"></div>
          <div class="note" id="historyEmpty" hidden>履歴はありません。</div>
        </div>
      </details>
      <div class="auth-container">
        <div class="auth-panel" id="teacherAuth" hidden>
          <div id="authStatus" class="note">未ログイン</div>
          <div id="authForm">
            <input id="authEmail" type="email" placeholder="メールアドレス" />
            <input id="authPassword" type="password" placeholder="パスワード" />
            <button id="authLoginBtn" type="button">ログイン</button>
          </div>
          <div id="authActions" hidden>
            <button id="authLogoutBtn" type="button">ログアウト</button>
          </div>
          <div id="authMessage" class="note"></div>
        </div>
      </div>
    </header>

    <main role="main" aria-label="学習ビュー">
    <div class="controls" role="search" aria-label="検索と絞り込み">
      <input id="keyword" type="text" placeholder="キーワード検索（例: #解剖学 筋）" aria-label="キーワード検索" />
      <details class="inline">
        <summary>詳細フィルタ</summary>
        <div class="row">
          <select id="subjectSelect" aria-label="科目の選択"><option value="">科目</option></select>
          <select id="subtopicSelect" aria-label="小項目の選択"><option value="">小項目</option></select>
          <select id="examTypeSelect" aria-label="試験種別の選択">
            <option value="">種別</option>
            <option value="A">A</option>
            <option value="B">B</option>
          </select>
          <select id="sessionSelect" aria-label="試験回数の選択"><option value="">回数</option></select>
        </div>
        <div class="row">
          <label><input type="checkbox" id="hasExplanation" /> 解説あり</label>
          <label><input type="checkbox" id="hasTags" /> タグあり</label>
          <label><input type="checkbox" id="hasSubtopics" /> 小項目あり</label>
        </div>
      </details>
      <button id="searchBtn" aria-label="検索を実行">検索</button>
      <button id="resetBtn" aria-label="検索条件をリセット">リセット</button>
    </div>

    <div class="toolbar">
      <label><input type="checkbox" id="toggleAnswer" aria-label="正答を表示" /> 正答を表示</label>
      <label><input type="checkbox" id="toggleExplanation" aria-label="正答と解説を表示" /> 正答・解説を表示</label>
      <span id="countInfo" aria-live="polite"></span>
    </div>

    <div class="toolbar main">
      <button id="copyAllBtn" aria-label="検索結果をコピー">検索結果をコピー</button>
      <button id="resetAnswersBtn" aria-label="回答履歴をリセット">回答履歴をリセット</button>
      <select id="sortSession" aria-label="試験回数でソート">
        <option value="">回数ソート</option>
        <option value="desc" selected>新しい順</option>
        <option value="asc">古い順</option>
      </select>
      <label><input type="checkbox" id="showAnswered" checked /> 回答済みの問題を表示</label>
    </div>
    <div class="results" id="results" role="region" aria-live="polite" aria-label="検索結果"></div>
    <div class="toolbar" id="resultsMore"></div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="./config.js"></script>
    <script>
      const SUPABASE_URL = window.SUPABASE_URL || "";
      const SUPABASE_KEY = window.SUPABASE_KEY || "";
      const supabaseClient =
        window.supabase && SUPABASE_URL && SUPABASE_KEY
          ? window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY)
          : null;
      const API_BASE =
        localStorage.getItem("reportApiBase") ||
        (location.port === "8001" ? "" : "http://127.0.0.1:8001");
      const state = {
        questions: [],
        indexBySubject: {},
        indexBySubtopic: {},
        subtopicsBySubject: {},
        answeredMap: {},
        subtopicCatalog: {},
        teacherSession: null,
        updateLog: [],
        updateShown: 0,
        orderIndexBySerial: {},
        overridesBySerial: {},
        overridesLoaded: new Set()
      };

      function populateSelect(select, items) {
        const first = select.querySelector("option");
        select.innerHTML = "";
        if (first) {
          select.appendChild(first);
        }
        items.forEach(item => {
          const opt = document.createElement("option");
          opt.value = item;
          opt.textContent = item;
          select.appendChild(opt);
        });
      }

      function loadData() {
        return Promise.all([
          fetch("../output/web/questions.json").then(r => r.json()),
          fetch("../output/web/index/index_by_subject.json").then(r => r.json()),
          fetch("../output/web/index/index_by_subtopic.json").then(r => r.json())
        ]).then(([questions, bySubject, bySubtopic]) => {
          state.questions = questions;
          state.indexBySubject = bySubject;
          state.indexBySubtopic = bySubtopic;
          state.subtopicsBySubject = buildSubtopicsBySubject(questions);
          state.orderIndexBySerial = {};
          questions.forEach((q, idx) => {
            if (q && q.serial) state.orderIndexBySerial[q.serial] = idx;
          });
        });
      }

      function loadSubtopicCatalog() {
        return fetch("../config/subtopics_catalog.json")
          .then(r => (r.ok ? r.json() : {}))
          .then(data => {
            state.subtopicCatalog = data || {};
          })
          .catch(() => {
            state.subtopicCatalog = {};
          });
      }

      function loadUpdateLog() {
        return fetch("../output/web/update_log.json")
          .then(r => (r.ok ? r.json() : []))
          .then(data => {
            state.updateLog = Array.isArray(data) ? data : [];
          })
          .catch(() => {
            state.updateLog = [];
          });
      }

      function loadUserReadme() {
        return fetch("./USER_README.md")
          .then(r => (r.ok ? r.text() : "利用ガイドを読み込めませんでした。"))
          .then(text => {
            const target = document.getElementById("userReadmeText");
            if (target) {
              target.textContent = text;
            }
          })
          .catch(() => {
            const target = document.getElementById("userReadmeText");
            if (target) {
              target.textContent = "利用ガイドを読み込めませんでした。";
            }
          });
      }

      function renderUpdateLog(targetCount) {
        const list = document.getElementById("updateList");
        const moreBtn = document.getElementById("updateMoreBtn");
        const empty = document.getElementById("updateEmpty");
        if (!list || !moreBtn || !empty) return;

        const total = state.updateLog.length;
        if (!total) {
          list.innerHTML = "";
          moreBtn.hidden = true;
          empty.hidden = false;
          state.updateShown = 0;
          return;
        }

        empty.hidden = true;
        const count = Math.min(targetCount, total);
        list.innerHTML = "";
        state.updateLog.slice(0, count).forEach(item => {
          const li = document.createElement("li");
          li.textContent = `${item.date}　${item.text}`;
          list.appendChild(li);
        });
        state.updateShown = count;
        moreBtn.hidden = state.updateShown >= total;
      }

      function buildSubtopicsBySubject(questions) {
        const map = {};
        questions.forEach(q => {
          const subject = q.subject || "";
          const subs = q.subtopics || [];
          if (!map[subject]) map[subject] = new Set();
          subs.forEach(s => map[subject].add(s));
        });
        const out = {};
        Object.keys(map).forEach(subject => {
          out[subject] = Array.from(map[subject]).sort();
        });
        return out;
      }

      function updateSubtopicOptions(subject) {
        const select = document.getElementById("subtopicSelect");
        const baseOption = document.createElement("option");
        baseOption.value = "";
        baseOption.textContent = subject ? "小項目" : "小項目(科目選択後)";
        select.innerHTML = "";
        select.appendChild(baseOption);
        if (!subject) {
          select.disabled = true;
          return;
        }
        select.disabled = false;
        const items = state.subtopicsBySubject[subject] || [];
        items.forEach(item => {
          const opt = document.createElement("option");
          opt.value = item;
          opt.textContent = item;
          select.appendChild(opt);
        });
      }

      function applyFilters({ subject, subtopic, keyword }) {
        const subjectSelect = document.getElementById("subjectSelect");
        const subtopicSelect = document.getElementById("subtopicSelect");
        const keywordInput = document.getElementById("keyword");

        if (subject !== undefined) {
          subjectSelect.value = subject;
          updateSubtopicOptions(subject);
        }
        if (subtopic !== undefined) {
          subtopicSelect.value = subtopic;
        }
        if (keyword !== undefined) {
          keywordInput.value = keyword;
        }
        renderResults(filterQuestions());
      }

      function filterQuestions() {
        const keyword = document.getElementById("keyword").value.trim();
        const subject = document.getElementById("subjectSelect").value;
        const subtopic = document.getElementById("subtopicSelect").value;
        const examType = document.getElementById("examTypeSelect").value;
        const session = document.getElementById("sessionSelect").value;
        const sortSession = document.getElementById("sortSession").value;
        const needExplanation = document.getElementById("hasExplanation").checked;
        const needTags = document.getElementById("hasTags").checked;
        const needSubtopics = document.getElementById("hasSubtopics").checked;
        const showAnswered = document.getElementById("showAnswered").checked;

        const terms = keyword
          .split(/\s+/)
          .map(term => term.trim().toLowerCase())
          .filter(Boolean);
        const tagTerms = terms.filter(term => term.startsWith("#")).map(term => term.slice(1));
        const textTerms = terms.filter(term => !term.startsWith("#"));
        const setFromIndex = (index, key) => new Set((index[key] || []));

        let serialSet = null;
        if (subject) serialSet = setFromIndex(state.indexBySubject, subject);
        if (subtopic) {
          const s = setFromIndex(state.indexBySubtopic, subtopic);
          serialSet = serialSet ? new Set([...serialSet].filter(x => s.has(x))) : s;
        }

        const filtered = state.questions.filter(q => {
          if (serialSet && !serialSet.has(q.serial)) return false;
          if (examType && !q.serial.startsWith(examType)) return false;
          if (session && String(q.exam_session) !== session) return false;
          if (!showAnswered && hasAnswered(q.serial)) return false;
          if (needExplanation && !(q.explanation_latest || "").trim()) return false;
          if (needTags && !(q.tags || []).length) return false;
          if (needSubtopics && !(q.subtopics || []).length) return false;
          if (!terms.length) return true;
          const hay = [
            q.stem || "",
            (q.choices || []).join(" "),
            q.case_text || "",
            (q.tags || []).join(" ")
          ].join(" ").toLowerCase();
          const tagMatch = tagTerms.every(tag => (q.tags || []).join(" ").toLowerCase().includes(tag));
          const textMatch = textTerms.every(term => hay.includes(term));
          return tagMatch && textMatch;
        });
        if (sortSession === "asc") {
          filtered.sort((a, b) => {
            const sessionDiff = (a.exam_session || 0) - (b.exam_session || 0);
            if (sessionDiff !== 0) return sessionDiff;
            const orderA = state.orderIndexBySerial[a.serial] || 0;
            const orderB = state.orderIndexBySerial[b.serial] || 0;
            return orderA - orderB;
          });
        } else if (sortSession === "desc") {
          filtered.sort((a, b) => {
            const sessionDiff = (b.exam_session || 0) - (a.exam_session || 0);
            if (sessionDiff !== 0) return sessionDiff;
            const orderA = state.orderIndexBySerial[a.serial] || 0;
            const orderB = state.orderIndexBySerial[b.serial] || 0;
            return orderA - orderB;
          });
        }
        return filtered;
      }

      function renderResults(list) {
        const container = document.getElementById("results");
        const moreContainer = document.getElementById("resultsMore");
        container.innerHTML = "";
        moreContainer.innerHTML = "";
        const isTeacher = Boolean(state.teacherSession);
        const showAnswer = isTeacher ? true : document.getElementById("toggleAnswer").checked;
        const showExplanation = isTeacher ? true : document.getElementById("toggleExplanation").checked;
        document.getElementById("countInfo").textContent = `件数: ${list.length}`;

        function appendCard(q, target) {
          const card = document.createElement("div");
          card.className = "card";
          if (isTeacher) {
            card.classList.add("show-explanation");
          }
          card.setAttribute("tabindex", "0");
          card.setAttribute("role", "group");
          card.setAttribute("aria-label", `問題 ${q.serial}`);
          if (showAnswer) {
            card.classList.add("show");
          }
          if (showExplanation) {
            card.classList.add("show-explanation");
          }

          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = `${q.serial} / ${q.subject} / 第${q.exam_session}回`;
          card.appendChild(meta);

          if (q.case_text) {
            const caseText = document.createElement("div");
            caseText.className = "case-text";
            caseText.textContent = q.case_text;
            card.appendChild(caseText);
          }

          const stem = document.createElement("div");
          stem.className = "stem";
          stem.textContent = q.stem || "";
          card.appendChild(stem);

          const ul = document.createElement("ol");
          ul.className = "choices";
          const nums = ["１", "２", "３", "４", "５", "６", "７", "８", "９"];
          const answered = getAnswered(q.serial);
          const correctIndex = Number(q.answer_index);
          (q.choices || []).forEach((choice, idx) => {
            const li = document.createElement("li");
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "choice-btn";
            btn.textContent = choice;
            btn.setAttribute("aria-label", `選択肢${idx + 1} ${choice}`);
            if (answered) {
              btn.disabled = true;
              if (idx + 1 === correctIndex) {
                btn.classList.add("correct");
              }
              if (answered.selectedIndex === idx + 1 && !answered.isCorrect) {
                btn.classList.add("incorrect");
              }
            }
            btn.addEventListener("click", () => {
              handleAnswerSelection(q, idx + 1, btn);
            });
            li.appendChild(btn);
            ul.appendChild(li);
          });
          card.appendChild(ul);

          const feedback = document.createElement("div");
          feedback.className = "choice-feedback";
          if (answered) {
            feedback.textContent = answered.isCorrect ? "正解" : "不正解";
          }
          card.appendChild(feedback);

          const tags = document.createElement("div");
          tags.className = "tagline";
          const tagsLabel = document.createElement("span");
          tagsLabel.className = "tag-label";
          tagsLabel.textContent = "タグ:";
          tags.appendChild(tagsLabel);
          const tagList = q.tags || [];
          if (!tagList.length) {
            const span = document.createElement("span");
            span.textContent = "(なし)";
            tags.appendChild(span);
          } else {
            tagList.forEach(tag => {
              const link = document.createElement("button");
              link.className = "chip-link";
              link.textContent = tag;
              link.setAttribute("aria-label", `タグ ${tag} で絞り込み`);
              link.addEventListener("click", () => {
                applyFilters({ keyword: `#${tag}` });
              });
              tags.appendChild(link);
            });
          }
          if (!isTeacher) {
            const tagReportWrap = buildReportRequest(
              q.serial,
              "tag",
              "タグ修正を要望"
            );
            tags.appendChild(tagReportWrap.button);
            tags.appendChild(tagReportWrap.panel);
          }
          if (isTeacher) {
            const tagDetails = document.createElement("details");
            tagDetails.className = "inline inline-details";
            const tagSummary = document.createElement("summary");
            tagSummary.className = "inline-summary";
            tagSummary.textContent = "タグ編集";
            tagDetails.appendChild(tagSummary);
            const tagPanel = document.createElement("div");
            tagPanel.className = "edit-panel";
            const tagRemoveWrap = document.createElement("div");
            (q.tags || []).forEach(tag => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = tag;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + tag));
              tagRemoveWrap.appendChild(lbl);
            });
            tagPanel.appendChild(tagRemoveWrap);
            const tagAdd = document.createElement("input");
            tagAdd.type = "text";
            tagAdd.placeholder = "追加タグ（カンマ区切り）";
            tagPanel.appendChild(tagAdd);
            const tagNote = document.createElement("input");
            tagNote.type = "text";
            tagNote.placeholder = "コメント（任意）";
            tagPanel.appendChild(tagNote);
            const tagSubmit = document.createElement("button");
            tagSubmit.textContent = "タグを反映";
            tagSubmit.addEventListener("click", () => {
              const remove = Array.from(tagRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = tagAdd.value.split(",").map(t => t.trim()).filter(Boolean);
              applyTagsOverride(q, add, remove, tagNote.value);
            });
            tagPanel.appendChild(tagSubmit);
            tagDetails.appendChild(tagPanel);
            tags.appendChild(tagDetails);
          }
          card.appendChild(tags);

          const subs = document.createElement("div");
          subs.className = "tagline";
          const subsLabel = document.createElement("span");
          subsLabel.className = "tag-label";
          subsLabel.textContent = "小項目:";
          subs.appendChild(subsLabel);
          const subList = q.subtopics || [];
          if (!subList.length) {
            const span = document.createElement("span");
            span.textContent = "(なし)";
            subs.appendChild(span);
          } else {
            subList.forEach(sub => {
              const link = document.createElement("button");
              link.className = "chip-link";
              link.textContent = sub;
              link.setAttribute("aria-label", `小項目 ${sub} で絞り込み`);
              link.addEventListener("click", () => {
                applyFilters({ subject: q.subject, subtopic: sub });
              });
              subs.appendChild(link);
            });
          }
          if (!isTeacher) {
            const subReportWrap = buildReportRequest(
              q.serial,
              "subtopic",
              "小項目修正を要望"
            );
            subs.appendChild(subReportWrap.button);
            subs.appendChild(subReportWrap.panel);
          }
          if (isTeacher) {
            const subDetails = document.createElement("details");
            subDetails.className = "inline inline-details";
            const subSummary = document.createElement("summary");
            subSummary.className = "inline-summary";
            subSummary.textContent = "小項目編集";
            subDetails.appendChild(subSummary);
            const subPanel = document.createElement("div");
            subPanel.className = "edit-panel";
            const subRemoveWrap = document.createElement("div");
            (q.subtopics || []).forEach(name => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = name;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + name));
              subRemoveWrap.appendChild(lbl);
            });
            subPanel.appendChild(subRemoveWrap);
            const subSelect = document.createElement("select");
            subSelect.multiple = true;
            subSelect.style.width = "100%";
            const catalog = state.subtopicCatalog[q.subject] || [];
            catalog.forEach(name => {
              const opt = document.createElement("option");
              opt.value = name;
              opt.textContent = name;
              subSelect.appendChild(opt);
            });
            subPanel.appendChild(subSelect);
            const subNote = document.createElement("input");
            subNote.type = "text";
            subNote.placeholder = "コメント（任意）";
            subPanel.appendChild(subNote);
            const subSubmit = document.createElement("button");
            subSubmit.textContent = "小項目を反映";
            subSubmit.addEventListener("click", () => {
              const remove = Array.from(subRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = Array.from(subSelect.selectedOptions).map(opt => opt.value);
              applySubtopicsOverride(q, add, remove, subNote.value);
            });
            subPanel.appendChild(subSubmit);
            subDetails.appendChild(subPanel);
            subs.appendChild(subDetails);
          }
          card.appendChild(subs);

          const answer = document.createElement("div");
          answer.className = "answer";
          const idx = q.answer_index ? q.answer_index : "";
          answer.textContent = `正答: ${idx}`;
          card.appendChild(answer);

          const explanation = document.createElement("div");
          explanation.className = "explanation";
          const expText = showExplanation || isTeacher ? (q.explanation_latest || "") : "";
          const expLabel = showExplanation || isTeacher ? formatExplanationLabel(q.explanation_latest_source) : "";
          const expHeader = document.createElement("div");
          expHeader.className = "explanation-header";
          const expTitle = document.createElement("span");
          expTitle.textContent = expText ? `解説${expLabel}:` : "解説: (未登録)";
          expHeader.appendChild(expTitle);
          if (!isTeacher) {
            if (q.explanations && q.explanations.length > 1) {
              const select = document.createElement("select");
              select.setAttribute("aria-label", "解説バージョンを選択");
              const label = document.createElement("option");
              label.value = "";
              label.textContent = "解説バージョン";
              select.appendChild(label);
              q.explanations.forEach(item => {
                const opt = document.createElement("option");
                opt.value = JSON.stringify({ body: item.body, source: item.source || "" });
                opt.textContent = `v${item.version}`;
                select.appendChild(opt);
              });
              select.addEventListener("change", () => {
                if (select.value) {
                  try {
                    const data = JSON.parse(select.value);
                    const label = formatExplanationLabel(data.source);
                    expTitle.textContent = `解説${label}:`;
                    expBody.textContent = data.body || "";
                  } catch (err) {
                    expTitle.textContent = "解説:";
                    expBody.textContent = select.value || "";
                  }
                } else {
                  expTitle.textContent = expText ? `解説${expLabel}:` : "解説: (未登録)";
                  expBody.textContent = expText || "";
                }
              });
              expHeader.appendChild(select);
            }
            const expReportWrap = buildReportRequest(
              q.serial,
              "explanation",
              "解説修正を要望"
            );
            expHeader.appendChild(expReportWrap.button);
            explanation.appendChild(expReportWrap.panel);
          }
          if (isTeacher) {
            const source = q.explanation_latest_source || "";
            const teacherLabel = formatExplanationLabel(source);
            expTitle.textContent = expText ? `解説${teacherLabel}:` : "解説: (未登録)";
            if (source === "llm_checked") {
              const expRevoke = document.createElement("button");
              expRevoke.textContent = "承認取消";
              expRevoke.addEventListener("click", () => {
                applyExplanationConfirm(q, "llm");
              });
              expHeader.appendChild(expRevoke);
            } else if (source !== "teacher" && source !== "human") {
              const expConfirm = document.createElement("button");
              expConfirm.textContent = "解説承認";
              expConfirm.addEventListener("click", () => {
                applyExplanationConfirm(q, "llm_checked");
              });
              expHeader.appendChild(expConfirm);
            }

            const expDetails = document.createElement("details");
            expDetails.className = "inline inline-details";
            const expSummary = document.createElement("summary");
            expSummary.className = "inline-summary";
            expSummary.textContent = "解説編集";
            expDetails.appendChild(expSummary);
            const expPanel = document.createElement("div");
            expPanel.className = "edit-panel";
            const expArea = document.createElement("textarea");
            expArea.rows = 4;
            expArea.value = expText || "";
            expPanel.appendChild(expArea);
            const expNote = document.createElement("input");
            expNote.type = "text";
            expNote.placeholder = "コメント（任意）";
            expPanel.appendChild(expNote);
            const expSubmit = document.createElement("button");
            expSubmit.textContent = "解説を反映";
            expSubmit.addEventListener("click", () => {
              applyExplanationEdit(q, expArea.value, expNote.value);
            });
            expPanel.appendChild(expSubmit);
            expDetails.appendChild(expPanel);
            expHeader.appendChild(expDetails);
          }
          explanation.appendChild(expHeader);
          const expBody = document.createElement("div");
          expBody.className = "explanation-body";
          expBody.textContent = expText || "";
          explanation.appendChild(expBody);
          card.appendChild(explanation);

          const actions = document.createElement("div");
          actions.className = "card-actions";
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "この問題をコピー";
          copyBtn.setAttribute("aria-label", "この問題をクリップボードにコピー");
          copyBtn.addEventListener("click", () => {
            const mode = getCopyMode();
            const text = formatQuestionForCopy(q, mode);
            copyToClipboard(text);
          });
          actions.appendChild(copyBtn);
          card.appendChild(actions);

          target.appendChild(card);
        }

        const subset = list;
        let idx = 0;
        const batchSize = 20;
        const more = document.createElement("button");
        const updateLabel = () => {
          more.textContent = `さらに表示 (${idx}/${subset.length})`;
        };
        function renderBatch(batch) {
          const frag = document.createDocumentFragment();
          batch.forEach(item => {
            appendCard(applyOverridesToQuestion(item), frag);
          });
          container.appendChild(frag);
        }
        async function renderChunk() {
          const end = Math.min(idx + batchSize, subset.length);
          const batch = subset.slice(idx, end);
          idx = end;
          more.disabled = true;
          await ensureOverridesLoaded(batch.map(item => item.serial));
          renderBatch(batch);
          more.disabled = false;
          updateLabel();
          if (idx >= subset.length) {
            more.remove();
          }
        }

        renderChunk();
        if (idx < subset.length) {
          updateLabel();
          more.addEventListener("click", () => {
            renderChunk();
          });
          moreContainer.appendChild(more);
        }
      }

      function init() {
        loadAnsweredState();
        loadSubtopicCatalog();
        const updateInfo = document.getElementById("updateInfo");
        const updateMoreBtn = document.getElementById("updateMoreBtn");
        loadUserReadme();
        loadUpdateLog().then(() => {
          if (updateInfo && updateInfo.open) {
            renderUpdateLog(3);
          }
        });
        loadData().then(() => {
          populateSelect(
            document.getElementById("subjectSelect"),
            Object.keys(state.indexBySubject)
          );
          updateSubtopicOptions("");
          populateSelect(
            document.getElementById("sessionSelect"),
            Array.from(new Set(state.questions.map(q => String(q.exam_session))))
              .sort((a, b) => Number(a) - Number(b))
          );
          renderResults(filterQuestions());
        });

        initAuthUI();
        if (updateInfo) {
          updateInfo.addEventListener("toggle", () => {
            if (updateInfo.open) {
              renderUpdateLog(3);
            }
          });
        }
        if (updateMoreBtn) {
          updateMoreBtn.addEventListener("click", () => {
            renderUpdateLog(state.updateShown + 3);
          });
        }

        initHistoryPanel();

        document.getElementById("searchBtn").addEventListener("click", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("resetBtn").addEventListener("click", () => {
          document.getElementById("keyword").value = "";
          document.getElementById("subjectSelect").value = "";
          document.getElementById("examTypeSelect").value = "";
          document.getElementById("sessionSelect").value = "";
          document.getElementById("sortSession").value = "desc";
          document.getElementById("showAnswered").checked = false;
          document.getElementById("hasExplanation").checked = false;
          document.getElementById("hasTags").checked = false;
          document.getElementById("hasSubtopics").checked = false;
          updateSubtopicOptions("");
          renderResults(filterQuestions());
        });
        document.getElementById("subjectSelect").addEventListener("change", (e) => {
          updateSubtopicOptions(e.target.value);
          renderResults(filterQuestions());
        });
        document.getElementById("subtopicSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("examTypeSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sessionSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sortSession").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("showAnswered").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasExplanation").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasTags").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasSubtopics").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("toggleAnswer").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("toggleExplanation").addEventListener("change", () => {
          renderResults(filterQuestions());
        });

      document.getElementById("copyAllBtn").addEventListener("click", async () => {
        const list = filterQuestions();
        await ensureOverridesLoaded(list.map(item => item.serial));
        const header = buildFilterHeader();
        const mode = getCopyMode();
        const body = list.map(q => formatQuestionForCopy(applyOverridesToQuestion(q), mode)).join("\n\n");
        copyToClipboard(`${header}\n\n${body}`.trim());
      });

      document.getElementById("resetAnswersBtn").addEventListener("click", () => {
        if (!confirm("回答履歴をリセットしますか？")) {
          return;
        }
        state.answeredMap = {};
        localStorage.removeItem("answeredSerials");
        renderResults(filterQuestions());
      });

        document.getElementById("keyword").addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            renderResults(filterQuestions());
          }
        });

        document.addEventListener("keydown", (e) => {
          const active = document.activeElement;
          const isInput =
            active &&
            (active.tagName === "INPUT" ||
              active.tagName === "TEXTAREA" ||
              active.tagName === "SELECT");
          if (isInput && e.key !== "Escape") {
            return;
          }
          if (e.key === "/") {
            e.preventDefault();
            document.getElementById("keyword").focus();
          } else if (e.key === "s") {
            document.getElementById("subjectSelect").focus();
          } else if (e.key === "u") {
            document.getElementById("subtopicSelect").focus();
          } else if (e.key === "f") {
            renderResults(filterQuestions());
          } else if (e.key === "r") {
            document.getElementById("resetBtn").click();
          } else if (e.key === "a") {
            const toggle = document.getElementById("toggleAnswer");
            toggle.checked = !toggle.checked;
            renderResults(filterQuestions());
          } else if (e.key === "e") {
            const toggle = document.getElementById("toggleExplanation");
            toggle.checked = !toggle.checked;
            renderResults(filterQuestions());
          }
        });
      }

      init();

      function sendReport(serial, kind, button, comment) {
        const anonId = getAnonId();
        if (supabaseClient) {
          supabaseClient
            .from("feedback")
            .insert([{ serial, kind, anon_id: anonId, comment: comment }])
            .then(({ error }) => {
              if (error) {
                button.classList.remove("reported");
                console.warn("報告に失敗しました。", error);
                return;
              }
              button.classList.add("reported");
            });
          return;
        }
        fetch(
          `${API_BASE}/api/report?serial=${encodeURIComponent(serial)}&kind=${encodeURIComponent(kind)}&comment=${encodeURIComponent(comment || "")}`,
          { mode: "cors" }
        )
          .then(resp => resp.json())
          .then(data => {
            if (data.message && data.message.startsWith("報告しました")) {
              button.classList.add("reported");
            } else {
              button.classList.remove("reported");
              console.warn(data.message || "報告に失敗しました。");
            }
          })
          .catch(err => {
            button.classList.remove("reported");
            console.warn("報告に失敗しました。", err);
          });
      }

      function initAuthUI() {
        const status = document.getElementById("authStatus");
        const form = document.getElementById("authForm");
        const actions = document.getElementById("authActions");
        const message = document.getElementById("authMessage");
        const emailInput = document.getElementById("authEmail");
        const passwordInput = document.getElementById("authPassword");
        const loginBtn = document.getElementById("authLoginBtn");
        const logoutBtn = document.getElementById("authLogoutBtn");
        const toggleBtn = document.getElementById("authToggleBtn");
        const panel = document.getElementById("teacherAuth");
        const historyPanel = document.getElementById("historyPanel");

        if (!supabaseClient) {
          status.textContent = "Supabase未設定";
          form.hidden = true;
          panel.hidden = true;
          toggleBtn.hidden = true;
          if (historyPanel) historyPanel.hidden = true;
          return;
        }

        toggleBtn.addEventListener("click", () => {
          const next = panel.hidden;
          panel.hidden = !next ? true : false;
          toggleBtn.setAttribute("aria-expanded", next ? "true" : "false");
        });

        supabaseClient.auth.getSession().then(({ data }) => {
          updateAuthUI(data.session);
        });
        supabaseClient.auth.onAuthStateChange((_event, session) => {
          updateAuthUI(session);
        });

        loginBtn.addEventListener("click", async () => {
          const email = emailInput.value.trim();
          const password = passwordInput.value;
          message.textContent = "";
          if (!email || !password) {
            message.textContent = "メールとパスワードを入力してください。";
            return;
          }
          const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
          if (error) {
            message.textContent = "ログインに失敗しました。";
            return;
          }
          message.textContent = "ログインしました。";
        });

        logoutBtn.addEventListener("click", async () => {
          message.textContent = "";
          const { error } = await supabaseClient.auth.signOut();
          if (error) {
            message.textContent = "ログアウトに失敗しました。";
            return;
          }
          message.textContent = "ログアウトしました。";
        });

        function isTeacherUser(user) {
          return (user?.app_metadata?.role || user?.user_metadata?.role || "") === "teacher";
        }

        function updateAuthUI(session) {
          const user = session && session.user ? session.user : null;
          if (user && !isTeacherUser(user)) {
            state.teacherSession = null;
            status.textContent = "教師権限がありません。";
            form.hidden = false;
            actions.hidden = true;
            toggleBtn.textContent = "教師ログイン";
            toggleBtn.setAttribute("aria-label", "教師ログイン");
            message.textContent = "教師アカウントでログインしてください。";
            if (historyPanel) historyPanel.hidden = true;
            supabaseClient.auth.signOut();
            return;
          }
          state.teacherSession = user ? session : null;
          if (user) {
            status.textContent = `ログイン中: ${user.email}`;
            form.hidden = true;
            actions.hidden = false;
            toggleBtn.textContent = "教師ログイン（ログイン中）";
            toggleBtn.setAttribute("aria-label", "教師ログイン（ログイン中）");
            if (historyPanel) historyPanel.hidden = false;
          } else {
            status.textContent = "未ログイン";
            form.hidden = false;
            actions.hidden = true;
            toggleBtn.textContent = "教師ログイン";
            toggleBtn.setAttribute("aria-label", "教師ログイン");
            if (historyPanel) historyPanel.hidden = true;
          }
          renderResults(filterQuestions());
        }
      }

      function submitEditRequest(serial, kind, payload, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const body = {
          serial: serial,
          kind: kind,
          payload: payload || {},
          note: note || "",
          status: "open",
          created_by: session.user.id,
          created_email: session.user.email
        };
        supabaseClient
          .from("edit_requests")
          .insert([body])
          .then(({ error }) => {
            if (error) {
              alert("送信に失敗しました。");
              return;
            }
            alert("編集提案を送信しました。");
          });
      }

      function applyTagsOverride(question, add, remove, note) {
        const before = { tags: question.tags || [] };
        const next = Array.from(
          new Set([...(question.tags || []), ...add].filter(tag => !remove.includes(tag)))
        );
        const after = { tags: next };
        applyOverrideChange(question.serial, "tags", before, after, { tags: next }, note);
      }

      function applySubtopicsOverride(question, add, remove, note) {
        const before = { subtopics: question.subtopics || [] };
        const next = Array.from(
          new Set([...(question.subtopics || []), ...add].filter(name => !remove.includes(name)))
        );
        const after = { subtopics: next };
        applyOverrideChange(question.serial, "subtopics", before, after, { subtopics: next }, note);
      }

      function applyExplanationConfirm(question, nextSource) {
        const current = question.explanation_latest_source || "";
        const normalized = nextSource || (current === "llm" || current === "ai" ? "llm_checked" : "llm_checked");
        const before = { explanation_source: current };
        const after = { explanation_source: normalized };
        applyOverrideChange(
          question.serial,
          "explanation",
          before,
          after,
          { explanation_source: normalized }
        );
      }

      function applyExplanationEdit(question, body, note) {
        const before = {
          explanation: question.explanation_latest || "",
          explanation_source: question.explanation_latest_source || ""
        };
        const after = {
          explanation: body,
          explanation_source: "teacher"
        };
        applyOverrideChange(
          question.serial,
          "explanation",
          before,
          after,
          { explanation: body, explanation_source: "teacher" },
          note
        );
      }

      function applyOverrideChange(serial, kind, beforeData, afterData, patch, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const payload = {
          serial,
          updated_at: new Date().toISOString(),
          updated_by: session.user.id,
          synced_at: null,
          ...patch
        };
        const history = {
          serial,
          kind,
          before_data: beforeData,
          after_data: afterData,
          approved_by: session.user.id
        };
        supabaseClient
          .from("question_overrides")
          .upsert(payload, { onConflict: "serial" })
          .then(({ error }) => {
            if (error) {
              alert(`反映に失敗しました: ${error.message}`);
              return;
            }
            supabaseClient
              .from("override_history")
              .insert([history])
              .then(({ error: historyError }) => {
                if (historyError) {
                  alert(`履歴の保存に失敗しました: ${historyError.message}`);
                  return;
                }
                const existing = state.overridesBySerial[serial] || {};
                state.overridesBySerial[serial] = { ...existing, ...patch };
                state.overridesLoaded.add(serial);
                const base = state.questions.find(item => item.serial === serial);
                if (base) {
                  if (Object.prototype.hasOwnProperty.call(patch, "explanation")) {
                    base.explanation_latest = patch.explanation;
                  }
                  if (Object.prototype.hasOwnProperty.call(patch, "explanation_source")) {
                    base.explanation_latest_source = patch.explanation_source;
                  }
                  if (Object.prototype.hasOwnProperty.call(patch, "tags")) {
                    base.tags = patch.tags;
                  }
                  if (Object.prototype.hasOwnProperty.call(patch, "subtopics")) {
                    base.subtopics = patch.subtopics;
                  }
                }
                const scrollY = window.scrollY;
                renderResults(filterQuestions());
                requestAnimationFrame(() => {
                  window.scrollTo(0, scrollY);
                });
              });
          });
      }

      async function ensureOverridesLoaded(serials) {
        if (!supabaseClient || !serials.length) return;
        const pending = serials.filter(serial => !state.overridesLoaded.has(serial));
        if (!pending.length) return;
        const chunkSize = 100;
        for (let i = 0; i < pending.length; i += chunkSize) {
          const chunk = pending.slice(i, i + chunkSize);
          const { data, error } = await supabaseClient
            .from("question_overrides")
            .select("serial, explanation, explanation_source, tags, subtopics")
            .in("serial", chunk)
            .is("synced_at", null);
          if (error) {
            console.warn("差分の取得に失敗しました。", error);
            return;
          }
          const map = {};
          (data || []).forEach(row => {
            map[row.serial] = row;
          });
          chunk.forEach(serial => {
            state.overridesBySerial[serial] = map[serial] || null;
            state.overridesLoaded.add(serial);
          });
          (data || []).forEach(row => {
            const base = state.questions.find(item => item.serial === row.serial);
            if (!base) return;
            if (row.explanation !== null && row.explanation !== undefined) {
              base.explanation_latest = row.explanation;
            }
            if (row.explanation_source !== null && row.explanation_source !== undefined) {
              base.explanation_latest_source = row.explanation_source;
            }
            if (row.tags !== null && row.tags !== undefined) {
              base.tags = row.tags;
            }
            if (row.subtopics !== null && row.subtopics !== undefined) {
              base.subtopics = row.subtopics;
            }
          });
        }
      }

      function applyOverridesToQuestion(q) {
        const override = state.overridesBySerial[q.serial];
        if (!override) return q;
        const merged = { ...q };
        if (override.explanation !== undefined && override.explanation !== null) {
          merged.explanation_latest = override.explanation;
          merged.explanation_latest_source =
            override.explanation_source || merged.explanation_latest_source;
        }
        if (override.tags !== undefined && override.tags !== null) {
          merged.tags = override.tags;
        }
        if (override.subtopics !== undefined && override.subtopics !== null) {
          merged.subtopics = override.subtopics;
        }
        return merged;
      }

      function initHistoryPanel() {
        const fetchBtn = document.getElementById("historyFetchBtn");
        if (!fetchBtn) return;
        fetchBtn.addEventListener("click", () => {
          fetchHistory();
        });
      }

      async function fetchHistory() {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const serialInput = document.getElementById("historySerial");
        const kindSelect = document.getElementById("historyKind");
        const serial = serialInput ? serialInput.value.trim() : "";
        const kind = kindSelect ? kindSelect.value : "";
        let query = supabaseClient
          .from("override_history")
          .select("id, serial, kind, before_data, after_data, created_at")
          .order("created_at", { ascending: false })
          .limit(50);
        if (serial) {
          query = query.eq("serial", serial);
        }
        if (kind) {
          query = query.eq("kind", kind);
        }
        const { data, error } = await query;
        if (error) {
          alert("履歴の取得に失敗しました。");
          return;
        }
        renderHistoryList(data || []);
      }

      function renderHistoryList(items) {
        const list = document.getElementById("historyList");
        const empty = document.getElementById("historyEmpty");
        if (!list || !empty) return;
        list.innerHTML = "";
        if (!items.length) {
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        items.forEach(item => {
          const wrap = document.createElement("div");
          wrap.className = "history-item";
          const meta = document.createElement("div");
          meta.className = "history-meta";
          const when = item.created_at ? new Date(item.created_at).toLocaleString() : "";
          meta.textContent = `${item.serial} / ${kindLabel(item.kind)} / ${when}`;
          wrap.appendChild(meta);
          const body = document.createElement("div");
          body.className = "history-body";
          body.textContent = formatHistoryBody(item);
          wrap.appendChild(body);
          const rollback = document.createElement("button");
          rollback.type = "button";
          rollback.textContent = "この版に戻す";
          rollback.addEventListener("click", () => {
            applyHistoryRollback(item);
          });
          wrap.appendChild(rollback);
          list.appendChild(wrap);
        });
      }

      function kindLabel(kind) {
        if (kind === "explanation") return "解説";
        if (kind === "tags") return "タグ";
        if (kind === "subtopics") return "小項目";
        return kind || "";
      }

      function formatHistoryBody(item) {
        const before = item.before_data || {};
        const after = item.after_data || {};
        if (item.kind === "explanation") {
          const beforeText = truncateText(before.explanation || "");
          const afterText = truncateText(after.explanation || "");
          const beforeLabel = formatExplanationLabel(before.explanation_source || "");
          const afterLabel = formatExplanationLabel(after.explanation_source || "");
          if (beforeText || afterText) {
            return `変更前${beforeLabel}: ${beforeText}\n変更後${afterLabel}: ${afterText}`;
          }
          return `変更前: ${before.explanation_source || "(空)"}\n変更後: ${after.explanation_source || "(空)"}`;
        }
        if (item.kind === "tags") {
          return `変更前: ${(before.tags || []).join(", ")}\n変更後: ${(after.tags || []).join(", ")}`;
        }
        if (item.kind === "subtopics") {
          return `変更前: ${(before.subtopics || []).join(", ")}\n変更後: ${(after.subtopics || []).join(", ")}`;
        }
        return JSON.stringify(item.after_data || {});
      }

      function truncateText(text) {
        if (!text) return "";
        return text.length > 160 ? `${text.slice(0, 160)}…` : text;
      }

      function applyHistoryRollback(item) {
        if (!confirm("この版に戻しますか？")) return;
        const base = state.questions.find(q => q.serial === item.serial);
        const current = base ? applyOverridesToQuestion(base) : null;
        if (!current) {
          alert("対象の問題が見つかりません。");
          return;
        }
        if (item.kind === "tags") {
          const before = { tags: current.tags || [] };
          const next = (item.before_data && item.before_data.tags) || [];
          const after = { tags: next };
          applyOverrideChange(item.serial, "tags", before, after, { tags: next }, "rollback");
          return;
        }
        if (item.kind === "subtopics") {
          const before = { subtopics: current.subtopics || [] };
          const next = (item.before_data && item.before_data.subtopics) || [];
          const after = { subtopics: next };
          applyOverrideChange(item.serial, "subtopics", before, after, { subtopics: next }, "rollback");
          return;
        }
        if (item.kind === "explanation") {
          const before = {
            explanation: current.explanation_latest || "",
            explanation_source: current.explanation_latest_source || ""
          };
          const nextBody = item.before_data ? item.before_data.explanation : "";
          const nextSource = item.before_data ? item.before_data.explanation_source : "";
          const after = {
            explanation: nextBody || "",
            explanation_source: nextSource || ""
          };
          const patch = {
            explanation: after.explanation,
            explanation_source: after.explanation_source
          };
          applyOverrideChange(item.serial, "explanation", before, after, patch, "rollback");
        }
      }

      function formatExplanationLabel(source) {
        if (!source) return "";
        if (source === "llm_checked") return "（AI承認済み）";
        if (source === "human" || source === "teacher") return "（教師編集）";
        if (source === "llm" || source === "ai") return "（AI）";
        return "（" + source + "）";
      }

      function buildReportRequest(serial, kind, label) {
        const panelId = `report-${serial}-${kind}`.replace(/[^a-zA-Z0-9_-]/g, "-");
        const button = document.createElement("button");
        button.className = "request-btn";
        button.textContent = label;
        button.setAttribute("aria-label", `${label}を送信`);
        button.setAttribute("aria-expanded", "false");
        button.setAttribute("aria-controls", panelId);

        const panel = document.createElement("div");
        panel.className = "request-panel";
        panel.hidden = true;
        panel.id = panelId;

        const textarea = document.createElement("textarea");
        textarea.rows = 3;
        textarea.placeholder = "修正内容のコメント（必須）";
        textarea.setAttribute("aria-label", `${label}のコメント`);

        const error = document.createElement("div");
        error.className = "note";
        error.textContent = "コメントを入力してください。";
        error.hidden = true;

        const submit = document.createElement("button");
        submit.textContent = "送信";

        button.addEventListener("click", () => {
          panel.hidden = !panel.hidden;
          if (!panel.hidden) {
            textarea.focus();
          }
          button.setAttribute("aria-expanded", panel.hidden ? "false" : "true");
        });

        submit.addEventListener("click", () => {
          const comment = textarea.value.trim();
          if (!comment) {
            error.hidden = false;
            textarea.setAttribute("aria-invalid", "true");
            return;
          }
          error.hidden = true;
          textarea.removeAttribute("aria-invalid");
          sendReport(serial, kind, button, comment);
          textarea.value = "";
          panel.hidden = true;
          button.setAttribute("aria-expanded", "false");
        });

        panel.appendChild(textarea);
        panel.appendChild(error);
        panel.appendChild(submit);

        return { button, panel };
      }

      function handleAnswerSelection(question, selectedIndex, button) {
        if (hasAnswered(question.serial)) {
          return;
        }
        const correctIndex = Number(question.answer_index);
        const isCorrect = Number(selectedIndex) === correctIndex;
        const buttons = button.closest("ol")?.querySelectorAll(".choice-btn") || [];
        buttons.forEach((btn, idx) => {
          btn.disabled = true;
          btn.classList.remove("selected", "correct", "incorrect");
          if (idx + 1 === correctIndex) {
            btn.classList.add("correct");
          }
        });
        if (!isCorrect) {
          button.classList.add("incorrect");
        }
        const feedback = button.closest(".card")?.querySelector(".choice-feedback");
        if (feedback) {
          feedback.textContent = isCorrect ? "正解" : "不正解";
        }
        const card = button.closest(".card");
        if (card) {
          card.classList.add("show-explanation");
        }
        markAnswered(question.serial, selectedIndex, isCorrect);
        const anonId = getAnonId();
        if (supabaseClient) {
          supabaseClient
            .from("answers")
            .insert([
              {
                serial: question.serial,
                is_correct: isCorrect,
                selected_index: selectedIndex,
                anon_id: anonId
              }
            ])
            .then(({ error }) => {
              if (error) {
                console.warn("回答の記録に失敗しました。", error);
              }
            });
        }
      }

      function hasAnswered(serial) {
        return Boolean(state.answeredMap[serial]);
      }

      function getAnswered(serial) {
        return state.answeredMap[serial] || null;
      }

      function markAnswered(serial, selectedIndex, isCorrect) {
        state.answeredMap[serial] = {
          selectedIndex: Number(selectedIndex),
          isCorrect: Boolean(isCorrect)
        };
        saveAnsweredState();
      }

      function loadAnsweredState() {
        const key = "answeredSerials";
        const raw = localStorage.getItem(key);
        if (!raw) return;
        try {
          const map = JSON.parse(raw);
          if (map && typeof map === "object") {
            Object.keys(map).forEach(serial => {
              state.answeredMap[serial] = map[serial];
            });
          }
        } catch (err) {
          localStorage.removeItem(key);
        }
      }

      function saveAnsweredState() {
        const key = "answeredSerials";
        localStorage.setItem(key, JSON.stringify(state.answeredMap));
      }

      function getAnonId() {
        const key = "anonId";
        let id = localStorage.getItem(key);
        if (id) return id;
        if (crypto && crypto.randomUUID) {
          id = crypto.randomUUID();
        } else {
          id = `${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
        }
        localStorage.setItem(key, id);
        return id;
      }

      function buildFilterHeader() {
        const keyword = document.getElementById("keyword").value.trim();
        const subject = document.getElementById("subjectSelect").value;
        const subtopic = document.getElementById("subtopicSelect").value;
        const examType = document.getElementById("examTypeSelect").value;
        const session = document.getElementById("sessionSelect").value;
        const sortSession = document.getElementById("sortSession").value;
        const showAnswered = document.getElementById("showAnswered").checked;
        const parts = [];
        if (keyword) parts.push(`キーワード: ${keyword}`);
        if (subject) parts.push(`科目: ${subject}`);
        if (subtopic) parts.push(`小項目: ${subtopic}`);
        if (examType) parts.push(`種別: ${examType}`);
        if (session) parts.push(`回数: ${session}`);
        if (sortSession) {
          const label = sortSession === "asc" ? "古い順" : "新しい順";
          parts.push(`回数ソート: ${label}`);
        }
        if (showAnswered) parts.push("回答済みを表示");
        return parts.length ? `検索条件: ${parts.join(" / ")}` : "検索条件: なし";
      }

      function getCopyMode() {
        const showAnswer = document.getElementById("toggleAnswer").checked;
        const showExplanation = document.getElementById("toggleExplanation").checked;
        return {
          showAnswer: showAnswer || showExplanation,
          showExplanation: showExplanation
        };
      }

      function formatQuestionForCopy(q, mode) {
        const showAnswer = mode && mode.showAnswer;
        const showExplanation = mode && mode.showExplanation;
        const lines = [];
        lines.push(`${q.serial}　${q.stem || ""}`);
        const choices = q.choices || [];
        const nums = ["１", "２", "３", "４", "５", "６", "７", "８", "９"];
        choices.forEach((choice, idx) => {
          const n = nums[idx] || String(idx + 1);
          lines.push(`${n}．${choice}`);
        });
        if (showAnswer) {
          lines.push("　");
          const ans = q.answer_index ? `解答　${nums[q.answer_index - 1] || q.answer_index}` : "解答　";
          lines.push(ans);
          if (showExplanation) {
            const exp = q.explanation_latest || "";
            if (exp) {
              lines.push("解説");
              lines.push(exp);
            }
          }
        }
        return lines.join("\n");
      }

      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text);
          return;
        }
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        textarea.remove();
      }
    </script>
  </body>
</html>
