<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ahaki Study Viewer</title>
    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "e88f0886e93c42adae0ff3dd06807843"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->
    <style>
      :root {
        --bg-1: #ffffff;
        --bg-2: #f1f5f9;
        --ink: #111111;
        --muted: #2b2b2b;
        --accent: #0b5cab;
        --card: #ffffff;
        --line: #4a4a4a;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
        color: var(--ink);
        background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
        min-height: 100vh;
      }
      header {
        padding: 28px 24px 10px;
      }
      .header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
      }
      h1 {
        margin: 0;
        font-size: clamp(24px, 4vw, 36px);
        letter-spacing: 0.5px;
      }
      .subtitle {
        color: var(--muted);
        margin-top: 6px;
        font-size: 14px;
      }
      .controls {
        display: grid;
        grid-template-columns: 1.6fr 1fr 1fr 1fr 1fr auto auto;
        gap: 10px;
        padding: 14px 24px 20px;
      }
      .controls input,
      .controls select,
      .controls button {
        padding: 10px 12px;
        border: 2px solid var(--line);
        border-radius: 10px;
        background: #fff;
        font-size: 14px;
      }
      .controls button {
        background: var(--accent);
        color: #fff;
        border: none;
        cursor: pointer;
      }
      .toolbar button {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .toolbar select {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .toolbar {
        padding: 0 24px 18px;
        display: flex;
        gap: 16px;
        align-items: center;
        color: var(--muted);
        font-size: 13px;
      }
      .toolbar.main {
        flex-wrap: wrap;
        gap: 10px;
      }
      .toolbar .auth-panel {
        margin-top: 0;
      }
      .results {
        padding: 0 24px 40px;
        display: grid;
        gap: 14px;
      }
      .card {
        background: var(--card);
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 16px 18px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        animation: fadeIn 250ms ease-in;
      }
      .meta {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        color: var(--muted);
        font-size: 12px;
      }
      .stem {
        margin: 10px 0 8px;
        font-size: 16px;
      }
      .case-text {
        margin: 10px 0 6px;
        padding: 8px 10px;
        background: #fff7e6;
        border-left: 4px solid #b67b0b;
        font-size: 13px;
        white-space: pre-wrap;
      }
      .choices {
        padding-left: 18px;
        margin: 6px 0;
      }
      .choice-btn {
        display: inline-block;
        width: 100%;
        text-align: left;
        border: none;
        background: transparent;
        padding: 4px 0;
        font-size: 14px;
        color: var(--ink);
        cursor: pointer;
      }
      .choice-btn:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }
      .choice-btn.selected {
        background: #e6f0ff;
        border-radius: 6px;
      }
      .choice-btn.correct {
        background: #e6f7ed;
        color: #0b5c2b;
        border-radius: 6px;
      }
      .choice-btn.incorrect {
        background: #ffe7ea;
        color: #7a0015;
        border-radius: 6px;
      }
      .choice-feedback {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      .tagline {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
      }
      .tag-label {
        font-weight: 600;
      }
      .chip-link {
        display: inline-block;
        margin: 2px 6px 0 0;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #fff;
        color: var(--muted);
        font-size: 12px;
        text-decoration: none;
        cursor: pointer;
      }
      .chip-link:hover {
        color: var(--ink);
        border-color: var(--accent);
      }
      .report-btn.reported {
        background: #ffe7ea;
        border-color: #b00020;
        color: #7a0015;
      }
      .proposal-list {
        margin-top: 8px;
        padding: 8px;
        border: 1px dashed var(--line);
        border-radius: 8px;
        background: #f8fafc;
        font-size: 0.9em;
      }
      .proposal-item {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px dashed var(--line);
      }
      .proposal-item:first-child {
        margin-top: 0;
        padding-top: 0;
        border-top: none;
      }
      .proposal-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .proposal-label {
        font-weight: 600;
        margin-right: 6px;
      }
      .answer {
        margin-top: 10px;
        padding: 8px 10px;
        border-left: 4px solid var(--accent);
        background: #e6f0ff;
        font-size: 13px;
        display: none;
      }
      .explanation {
        margin-top: 8px;
        padding: 8px 10px;
        border-left: 4px solid #0b7a5c;
        background: #e8f7f2;
        font-size: 13px;
        white-space: pre-wrap;
        display: none;
      }
      .answer-stats {
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px dashed var(--line);
        font-size: 12px;
        color: var(--muted);
      }
      .card-actions {
        margin-top: 10px;
      }
      .note {
        color: var(--muted);
        font-size: 12px;
      }
      .update-list {
        margin: 6px 0 8px;
        padding-left: 18px;
        font-size: 12px;
      }
      .update-list li {
        margin: 4px 0;
      }
      .user-readme {
        margin: 6px 0;
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
        white-space: pre-wrap;
      }
      details.inline {
        margin-top: 8px;
      }
      details.inline > summary {
        cursor: pointer;
        font-size: 12px;
        color: var(--muted);
      }
      details.inline > summary.inline-summary {
        list-style: none;
        display: inline-block;
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
        color: var(--ink);
      }
      details.inline > summary.inline-summary::-webkit-details-marker {
        display: none;
      }
      .edit-panel {
        margin-top: 6px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
      }
      .edit-grid {
        display: grid;
        gap: 6px;
      }
      .edit-grid label {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .edit-panel input,
      .edit-panel select,
      .edit-panel textarea,
      .edit-panel button {
        margin-top: 6px;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid var(--line);
        font-size: 12px;
      }
      .edit-panel textarea {
        width: 100%;
      }
      .explanation-header {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .explanation-body {
        margin-top: 6px;
        white-space: pre-wrap;
      }
      .inline-details[open] {
        flex-basis: 100%;
      }
      .inline-details[open] .edit-panel {
        width: 100%;
      }
      .auth-panel {
        margin-top: 8px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
      }
      .auth-panel input {
        width: 220px;
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        margin-right: 6px;
      }
      .history-panel {
        margin-top: 10px;
        padding: 10px 12px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 13px;
      }
      .history-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .history-controls input,
      .history-controls select,
      .history-controls button {
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        background: #fff;
        font-size: 12px;
      }
      .history-list {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }
      .history-item {
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px 10px;
        background: #f8fafc;
      }
      .history-meta {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      .history-body {
        font-size: 13px;
        white-space: pre-wrap;
      }
      .history-item button {
        margin-top: 6px;
        padding: 4px 8px;
        font-size: 12px;
      }
      .proposal-panel {
        margin-top: 10px;
      }
      .proposal-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 10px;
      }
      .proposal-controls input,
      .proposal-controls select,
      .proposal-controls button {
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 6px;
        background: #fff;
        font-size: 12px;
      }
      .proposal-list-wide {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        padding: 8px;
        font-size: 12px;
      }
      .proposal-row {
        border-top: 1px solid var(--line);
        padding: 8px 0;
      }
      .proposal-row:first-child {
        border-top: none;
        padding-top: 0;
      }
      body:not(.report-mode) .guest-report {
        display: none;
      }
      .is-hidden {
        display: none;
      }
      .proposal-meta {
        color: var(--muted);
        font-size: 11px;
        margin-bottom: 4px;
      }
      .frequent-badge {
        margin-left: 8px;
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 700;
      }
      .frequent-badge.level-1 {
        background: #e6f1ff;
        color: #0b3b75;
      }
      .frequent-badge.level-2 {
        background: #ffe6a3;
        color: #5a2c00;
      }
      .frequent-badge.level-3 {
        background: #ffd1b8;
        color: #5a1f00;
      }
      .frequent-tags {
        margin-left: 6px;
        font-size: 11px;
        color: var(--muted);
      }
      .auth-panel .note {
        margin-top: 6px;
        color: var(--muted);
        font-size: 11px;
      }
      .auth-toggle {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .auth-container {
        padding: 0 24px 12px;
      }
      .auth-panel[hidden] {
        display: none;
      }
      .card-actions button,
      .card-actions select {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      .request-btn {
        padding: 6px 10px;
        border-radius: 8px;
        border: 2px solid var(--accent);
        background: #fff;
        color: var(--accent);
        cursor: pointer;
        font-size: 12px;
      }
      .request-btn.reported {
        background: #ffe7ea;
        border-color: #b00020;
        color: #7a0015;
      }
      .request-panel {
        margin-top: 6px;
        padding: 8px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        font-size: 12px;
        flex-basis: 100%;
        width: 100%;
      }
      .request-panel textarea,
      .request-panel button {
        margin-top: 6px;
        font-size: 12px;
      }
      .request-panel textarea {
        width: 100%;
        min-height: 96px;
        resize: vertical;
      }
      .show .answer { display: block; }
      .show-explanation .answer { display: block; }
      .show-explanation .explanation { display: block; }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(6px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @media (max-width: 900px) {
        .controls {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-row">
        <h1>Ahaki Study Viewer</h1>
        <button id="authToggleBtn" class="auth-toggle" aria-expanded="false">教師ログイン</button>
      </div>
      <div class="subtitle">検索・絞り込み・学習用の簡易ビュー</div>
      <div class="subtitle"><a href="./simple.html">かんたんビューを開く</a></div>
      <details class="inline" id="updateInfo">
        <summary>更新情報</summary>
        <div class="card-actions">
          <ul class="update-list" id="updateList"></ul>
          <button id="updateMoreBtn" type="button">さらに表示</button>
          <div class="note" id="updateEmpty" hidden>更新情報はありません。</div>
        </div>
      </details>
      <details class="inline" id="userReadme">
        <summary>利用ガイド</summary>
        <div class="card-actions">
          <pre class="user-readme" id="userReadmeText">読み込み中...</pre>
        </div>
      </details>
      <details class="inline" id="historyPanel" hidden>
        <summary>編集履歴</summary>
        <div class="history-panel">
          <div class="history-controls">
            <input id="historySerial" type="text" placeholder="シリアル (例: A01-001)" />
            <select id="historyKind">
              <option value="">すべて</option>
              <option value="explanation">解説</option>
              <option value="case_text">症例文</option>
              <option value="stem">問題文</option>
              <option value="choices">選択肢</option>
              <option value="answer">模範解答</option>
              <option value="tags">タグ</option>
              <option value="subtopics">小項目</option>
            </select>
            <button id="historyFetchBtn" type="button">履歴を取得</button>
          </div>
          <div class="history-list" id="historyList"></div>
          <div class="note" id="historyEmpty" hidden>履歴はありません。</div>
        </div>
      </details>
      <details class="inline" id="proposalPanel" hidden>
        <summary>修正提案一覧</summary>
        <div class="proposal-panel">
          <div class="proposal-controls">
            <input id="proposalSerial" type="text" placeholder="シリアル (任意)" />
            <select id="proposalStatus">
              <option value="open">未処理</option>
              <option value="applied">反映済み</option>
              <option value="rejected">却下</option>
              <option value="">すべて</option>
            </select>
            <button id="proposalFetchBtn" type="button">提案を取得</button>
          </div>
          <div class="proposal-list-wide" id="proposalList"></div>
          <div class="note" id="proposalEmpty" hidden>提案はありません。</div>
        </div>
      </details>
      <details class="inline" id="tagDisablePanel" hidden>
        <summary>タグ無効化</summary>
        <div class="edit-panel">
          <input id="disableTagInput" type="text" placeholder="無効化するタグ（カンマ区切り）" />
          <button id="disableTagAddBtn" type="button">無効化する</button>
          <div id="disabledTagList"></div>
        </div>
      </details>
      <div class="auth-container">
        <div class="auth-panel" id="teacherAuth" hidden>
          <div id="authStatus" class="note">未ログイン</div>
        <div id="authForm">
          <input id="authEmail" type="email" placeholder="メールアドレス" />
          <input id="authPassword" type="password" placeholder="パスワード" />
          <button id="authLoginBtn" type="button">ログイン</button>
        </div>
        <details class="inline" id="teacherSignupPanel">
          <summary>教師アカウントを申請</summary>
          <div class="edit-panel">
            <input id="signupEmail" type="email" placeholder="メールアドレス" />
            <input id="signupPassword" type="password" placeholder="パスワード" />
            <input id="signupPasswordConfirm" type="password" placeholder="パスワード（確認）" />
            <input id="signupNote" type="text" placeholder="申請理由（任意）" />
            <button id="signupBtn" type="button">申請する</button>
            <div class="note">申請後、管理者の承認が必要です。</div>
          </div>
        </details>
        <div id="authActions" hidden>
          <button id="authLogoutBtn" type="button">ログアウト</button>
        </div>
        <div id="authMessage" class="note"></div>
        </div>
      </div>
    </header>

    <main role="main" aria-label="学習ビュー">
    <div class="controls" role="search" aria-label="検索と絞り込み">
      <input id="keyword" type="text" placeholder="キーワード検索（例: #解剖学 筋）" aria-label="キーワード検索" />
      <details class="inline">
        <summary>詳細設定</summary>
        <div class="row">
          <select id="subjectSelect" aria-label="科目の選択"><option value="">科目</option></select>
          <select id="subtopicSelect" aria-label="小項目の選択"><option value="">小項目</option></select>
          <select id="examTypeSelect" aria-label="試験種別の選択">
            <option value="">種別</option>
            <option value="A">A</option>
            <option value="B">B</option>
          </select>
          <input id="sessionFrom" type="number" min="1" placeholder="回数From" aria-label="試験回数の開始" />
          <input id="sessionTo" type="number" min="1" placeholder="回数To" aria-label="試験回数の終了" />
        </div>
        <div class="row">
          <label><input type="checkbox" id="hasExplanation" /> 解説あり</label>
          <label><input type="checkbox" id="hasTags" /> タグあり</label>
          <label><input type="checkbox" id="hasSubtopics" /> 小項目あり</label>
          <label><input type="checkbox" id="onlyFrequent" /> 頻出のみ</label>
        </div>
        <div class="row">
          <label><input type="checkbox" id="toggleAnswer" aria-label="正答を表示" /> 正答を表示</label>
          <label><input type="checkbox" id="toggleExplanation" aria-label="正答と解説を表示" /> 正答・解説を表示</label>
          <button id="resetAnswersBtn" aria-label="回答履歴をリセット">回答履歴をリセット</button>
        </div>
        <div class="row">
          <label><input type="checkbox" id="showAnswered" checked /> 回答済みの問題を表示</label>
          <label><input type="checkbox" id="showTagsToggle" /> タグを表示</label>
          <label><input type="checkbox" id="showSubtopicsToggle" /> 小項目を表示</label>
          <label id="reportModeWrap" hidden><input type="checkbox" id="reportModeToggle" /> 修正要望モード</label>
        </div>
      </details>
      <button id="searchBtn" aria-label="検索を実行">検索</button>
      <button id="resetBtn" aria-label="検索条件をリセット">リセット</button>
    </div>

    <div class="toolbar main">
      <button id="copyAllBtn" aria-label="検索結果をコピー">検索結果をコピー</button>
      <select id="sortSession" aria-label="並び替え">
        <option value="">並び替え</option>
        <option value="desc" selected>新しい順</option>
        <option value="asc">古い順</option>
        <option value="frequent_desc">頻出順</option>
        <option value="frequent_asc">頻出（低い順）</option>
        <option value="count_desc">回答数が多い順</option>
        <option value="count_asc">回答数が少ない順</option>
        <option value="correct_desc">正答数が多い順</option>
        <option value="correct_asc">正答数が少ない順</option>
        <option value="rate_desc">正答率が高い順</option>
        <option value="rate_asc">正答率が低い順</option>
      </select>
      <span id="countInfo" aria-live="polite"></span>
    </div>
    <div class="results" id="results" role="region" aria-live="off" aria-label="検索結果"></div>
    <div class="toolbar" id="resultsMore"></div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="./config.js"></script>
    <script>
      const SUPABASE_URL = window.SUPABASE_URL || "";
      const SUPABASE_KEY = window.SUPABASE_KEY || "";
      const supabaseClient =
        window.supabase && SUPABASE_URL && SUPABASE_KEY
          ? window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY)
          : null;
      const API_BASE =
        localStorage.getItem("reportApiBase") ||
        (location.port === "8001" ? "" : "http://127.0.0.1:8001");
      const state = {
        questions: [],
        indexBySubject: {},
        indexBySubtopic: {},
        subtopicsBySubject: {},
        answeredMap: {},
        sessionAnswered: {},
        subtopicCatalog: {},
        teacherSession: null,
        teacherUserId: null,
        updateLog: [],
        updateShown: 0,
        orderIndexBySerial: {},
        overridesBySerial: {},
        overridesLoaded: new Set(),
        editRequestsBySerial: {},
        editRequestsLoaded: new Set(),
        answerStatsBySerial: {},
        answerStatsLoaded: new Set(),
        reportMode: false,
        showTags: false,
        showSubtopics: false,
        disabledTags: new Set()
      };

      function normalizeAscii(text) {
        return (text || "")
          .replace(/[Ａ-Ｚａ-ｚ０-９]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0))
          .replace(/[‐‑‒–—―−ーｰ－]/g, "-");
      }

      function normalizeSerialTerm(raw) {
        if (!raw) return "";
        let text = normalizeAscii(raw).toUpperCase();
        text = text.replace(/\s+/g, "");
        text = text.replace(/^[^A-Z0-9]+|[^A-Z0-9]+$/g, "");
        let match = text.match(/^([AB])(\d{2})(\d{3})$/);
        if (match) return `${match[1]}${match[2]}-${match[3]}`;
        match = text.match(/^([AB])(\d{1,2})-(\d{1,3})$/);
        if (match) {
          return `${match[1]}${match[2].padStart(2, "0")}-${match[3].padStart(3, "0")}`;
        }
        match = text.match(/^([AB])(\d{4,5})$/);
        if (match) {
          const digits = match[2];
          const session = digits.slice(0, -3).padStart(2, "0");
          const number = digits.slice(-3).padStart(3, "0");
          return `${match[1]}${session}-${number}`;
        }
        return "";
      }

      function populateSelect(select, items) {
        const first = select.querySelector("option");
        select.innerHTML = "";
        if (first) {
          select.appendChild(first);
        }
        items.forEach(item => {
          const opt = document.createElement("option");
          opt.value = item;
          opt.textContent = item;
          select.appendChild(opt);
        });
      }

      function loadData() {
        return Promise.all([
          fetch("../output/web/questions.json").then(r => r.json()),
          fetch("../output/web/index/index_by_subject.json").then(r => r.json()),
          fetch("../output/web/index/index_by_subtopic.json").then(r => r.json())
        ]).then(([questions, bySubject, bySubtopic]) => {
          state.questions = questions;
          state.indexBySubject = bySubject;
          state.indexBySubtopic = bySubtopic;
          state.subtopicsBySubject = buildSubtopicsBySubject(questions);
          state.orderIndexBySerial = {};
          questions.forEach((q, idx) => {
            if (q && q.serial) state.orderIndexBySerial[q.serial] = idx;
          });
        });
      }

      function loadSubtopicCatalog() {
        return fetch("../config/subtopics_catalog.json")
          .then(r => (r.ok ? r.json() : {}))
          .then(data => {
            state.subtopicCatalog = data || {};
          })
          .catch(() => {
            state.subtopicCatalog = {};
          });
      }

      function loadUpdateLog() {
        return fetch("../output/web/update_log.json")
          .then(r => (r.ok ? r.json() : []))
          .then(data => {
            state.updateLog = Array.isArray(data) ? data : [];
          })
          .catch(() => {
            state.updateLog = [];
          });
      }

      function loadUserReadme() {
        return fetch("./USER_README.md")
          .then(r => (r.ok ? r.text() : "利用ガイドを読み込めませんでした。"))
          .then(text => {
            const target = document.getElementById("userReadmeText");
            if (target) {
              target.textContent = text;
            }
          })
          .catch(() => {
            const target = document.getElementById("userReadmeText");
            if (target) {
              target.textContent = "利用ガイドを読み込めませんでした。";
            }
          });
      }

      function renderUpdateLog(targetCount) {
        const list = document.getElementById("updateList");
        const moreBtn = document.getElementById("updateMoreBtn");
        const empty = document.getElementById("updateEmpty");
        if (!list || !moreBtn || !empty) return;

        const total = state.updateLog.length;
        if (!total) {
          list.innerHTML = "";
          moreBtn.hidden = true;
          empty.hidden = false;
          state.updateShown = 0;
          return;
        }

        empty.hidden = true;
        const count = Math.min(targetCount, total);
        list.innerHTML = "";
        state.updateLog.slice(0, count).forEach(item => {
          const li = document.createElement("li");
          li.textContent = `${item.date}　${item.text}`;
          list.appendChild(li);
        });
        state.updateShown = count;
        moreBtn.hidden = state.updateShown >= total;
      }

      function buildSubtopicsBySubject(questions) {
        const map = {};
        questions.forEach(q => {
          const subject = q.subject || "";
          const subs = q.subtopics || [];
          if (!map[subject]) map[subject] = new Set();
          subs.forEach(s => map[subject].add(s));
        });
        const out = {};
        Object.keys(map).forEach(subject => {
          out[subject] = Array.from(map[subject]).sort();
        });
        return out;
      }

      function updateSubtopicOptions(subject) {
        const select = document.getElementById("subtopicSelect");
        const baseOption = document.createElement("option");
        baseOption.value = "";
        baseOption.textContent = subject ? "小項目" : "小項目(科目選択後)";
        select.innerHTML = "";
        select.appendChild(baseOption);
        if (!subject) {
          select.disabled = true;
          return;
        }
        select.disabled = false;
        const items = state.subtopicsBySubject[subject] || [];
        items.forEach(item => {
          const opt = document.createElement("option");
          opt.value = item;
          opt.textContent = item;
          select.appendChild(opt);
        });
      }

      function applyFilters({ subject, subtopic, keyword }) {
        const subjectSelect = document.getElementById("subjectSelect");
        const subtopicSelect = document.getElementById("subtopicSelect");
        const keywordInput = document.getElementById("keyword");

        if (subject !== undefined) {
          subjectSelect.value = subject;
          updateSubtopicOptions(subject);
        }
        if (subtopic !== undefined) {
          subtopicSelect.value = subtopic;
        }
        if (keyword !== undefined) {
          keywordInput.value = keyword;
        }
        renderResults(filterQuestions());
      }

      function filterQuestions() {
        const keyword = document.getElementById("keyword").value.trim();
        const subject = document.getElementById("subjectSelect").value;
        const subtopic = document.getElementById("subtopicSelect").value;
        const examType = document.getElementById("examTypeSelect").value;
        const sessionFromRaw = document.getElementById("sessionFrom").value;
        const sessionToRaw = document.getElementById("sessionTo").value;
        const sortSession = document.getElementById("sortSession").value;
        const needExplanation = document.getElementById("hasExplanation").checked;
        const needTags = document.getElementById("hasTags").checked;
        const needSubtopics = document.getElementById("hasSubtopics").checked;
        const onlyFrequent = document.getElementById("onlyFrequent").checked;
        const showAnswered = document.getElementById("showAnswered").checked;
        const sessionFrom = sessionFromRaw ? Number(sessionFromRaw) : null;
        const sessionTo = sessionToRaw ? Number(sessionToRaw) : null;

        const terms = keyword
          .split(/[\s,]+/)
          .map(term => term.trim())
          .filter(Boolean);
        const tagTerms = [];
        const textTerms = [];
        const serialTerms = [];
        terms.forEach(term => {
          const lowered = normalizeAscii(term).toLowerCase();
          if (lowered.startsWith("#")) {
            tagTerms.push(lowered.slice(1));
            return;
          }
          const serial = normalizeSerialTerm(term);
          if (serial) {
            serialTerms.push(serial);
            return;
          }
          if (lowered) textTerms.push(lowered);
        });
        const setFromIndex = (index, key) => new Set((index[key] || []));

        let serialSet = null;
        if (subject) serialSet = setFromIndex(state.indexBySubject, subject);
        const subtopicFilter = subtopic;

        const filtered = state.questions.filter(q => {
          const effective = applyOverridesToQuestion(q);
          if (serialSet && !serialSet.has(effective.serial)) return false;
          if (examType && !effective.serial.startsWith(examType)) return false;
        if (sessionFrom !== null && Number(effective.exam_session) < sessionFrom) return false;
        if (sessionTo !== null && Number(effective.exam_session) > sessionTo) return false;
          if (!showAnswered && hasAnswered(effective.serial)) return false;
          if (needExplanation && !(effective.explanation_latest || "").trim()) return false;
          if (needTags && !(effective.tags || []).length) return false;
          if (needSubtopics && !(effective.subtopics || []).length) return false;
          if (onlyFrequent && !(Number(effective.frequent_level) > 0)) return false;
          if (subtopicFilter && !(effective.subtopics || []).includes(subtopicFilter)) return false;
          if (serialTerms.length && !serialTerms.includes(effective.serial)) return false;
          if (!terms.length) return true;
          const hay = [
            effective.stem || "",
            (effective.choices || []).join(" "),
            effective.case_text || "",
            (effective.tags || []).join(" "),
            (effective.subtopics || []).join(" ")
          ].join(" ").toLowerCase();
          const tagMatch = tagTerms.every(tag => (effective.tags || []).join(" ").toLowerCase().includes(tag));
          const textMatch = textTerms.every(term => hay.includes(term));
          return tagMatch && textMatch;
        });
        const getStats = (q) => state.answerStatsBySerial[q.serial] || { count: 0, correct: 0 };
        const getRate = (q) => {
          const stats = getStats(q);
          return stats.count ? stats.correct / stats.count : 0;
        };
        if (sortSession === "asc") {
          filtered.sort((a, b) => {
            const sessionDiff = (a.exam_session || 0) - (b.exam_session || 0);
            if (sessionDiff !== 0) return sessionDiff;
            const orderA = state.orderIndexBySerial[a.serial] || 0;
            const orderB = state.orderIndexBySerial[b.serial] || 0;
            return orderA - orderB;
          });
        } else if (sortSession === "desc") {
          filtered.sort((a, b) => {
            const sessionDiff = (b.exam_session || 0) - (a.exam_session || 0);
            if (sessionDiff !== 0) return sessionDiff;
            const orderA = state.orderIndexBySerial[a.serial] || 0;
            const orderB = state.orderIndexBySerial[b.serial] || 0;
            return orderA - orderB;
          });
        } else if (sortSession === "count_desc") {
          filtered.sort((a, b) => getStats(b).count - getStats(a).count);
        } else if (sortSession === "count_asc") {
          filtered.sort((a, b) => getStats(a).count - getStats(b).count);
        } else if (sortSession === "correct_desc") {
          filtered.sort((a, b) => getStats(b).correct - getStats(a).correct);
        } else if (sortSession === "correct_asc") {
          filtered.sort((a, b) => getStats(a).correct - getStats(b).correct);
        } else if (sortSession === "rate_desc") {
          filtered.sort((a, b) => getRate(b) - getRate(a));
        } else if (sortSession === "rate_asc") {
          filtered.sort((a, b) => getRate(a) - getRate(b));
        } else if (sortSession === "frequent_desc") {
          filtered.sort((a, b) => (Number(b.frequent_score) || 0) - (Number(a.frequent_score) || 0));
        } else if (sortSession === "frequent_asc") {
          filtered.sort((a, b) => (Number(a.frequent_score) || 0) - (Number(b.frequent_score) || 0));
        }
        return filtered;
      }

      function renderResults(list) {
        const container = document.getElementById("results");
        const moreContainer = document.getElementById("resultsMore");
        container.innerHTML = "";
        moreContainer.innerHTML = "";
        const isTeacher = Boolean(state.teacherSession);
        const showAnswer = document.getElementById("toggleAnswer").checked;
        const showExplanation = document.getElementById("toggleExplanation").checked;
        document.getElementById("countInfo").textContent = `件数: ${list.length}`;
        const sortSession = document.getElementById("sortSession").value;
        const isStatSort = [
          "count_desc",
          "count_asc",
          "correct_desc",
          "correct_asc",
          "rate_desc",
          "rate_asc"
        ].includes(sortSession);

        function appendCard(q, target) {
          const card = document.createElement("div");
          card.className = "card";
        card.setAttribute("tabindex", "0");
          card.setAttribute("role", "group");
          card.setAttribute("aria-label", `問題 ${q.serial}`);
          if (showAnswer) {
            card.classList.add("show");
          }
          if (showExplanation) {
            card.classList.add("show-explanation");
          }

          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = `${q.serial} / ${q.subject} / 第${q.exam_session}回`;
          if (hasAnswered(q.serial)) {
            const answered = document.createElement("span");
            answered.className = "frequent-badge level-1";
            answered.textContent = "回答済み";
            meta.appendChild(answered);
          }
          const level = Number(q.frequent_level) || 0;
          if (level > 0) {
            const badge = document.createElement("span");
            badge.className = `frequent-badge level-${level}`;
            badge.textContent = level === 3 ? "頻出 高" : level === 2 ? "頻出 中" : "頻出 低";
            const tags = (q.frequent_tags || []).slice(0, 2);
            if (tags.length) {
              badge.title = `頻出タグ: ${tags.join(", ")}`;
            }
            meta.appendChild(badge);
            if (q.frequent_tags && q.frequent_tags.length) {
              const tagLabel = document.createElement("span");
              tagLabel.className = "frequent-tags";
              tagLabel.textContent = q.frequent_tags.slice(0, 2).join(" / ");
              meta.appendChild(tagLabel);
            }
          }
          card.appendChild(meta);

          if (q.case_text) {
            const caseText = document.createElement("div");
            caseText.className = "case-text";
            caseText.textContent = q.case_text;
            card.appendChild(caseText);
          }
          if (!isTeacher) {
            const caseDetails = document.createElement("details");
            caseDetails.className = "inline inline-details";
            caseDetails.classList.add("guest-report");
            const caseSummary = document.createElement("summary");
            caseSummary.className = "inline-summary";
            caseSummary.textContent = "症例文の誤りを報告";
            caseDetails.appendChild(caseSummary);
            const casePanel = document.createElement("div");
            casePanel.className = "edit-panel";
            const caseArea = document.createElement("textarea");
            caseArea.rows = 3;
            caseArea.value = q.case_text || "";
            caseArea.placeholder = "症例文の修正案";
            casePanel.appendChild(caseArea);
            const caseNote = document.createElement("input");
            caseNote.type = "text";
            caseNote.placeholder = "コメント（必須）";
            casePanel.appendChild(caseNote);
            const caseSubmit = document.createElement("button");
            caseSubmit.textContent = "提案を送信";
            caseSubmit.addEventListener("click", () => {
              submitGuestEditRequest(
                q.serial,
                "case_text",
                { case_text: caseArea.value },
                caseNote.value
              );
            });
            casePanel.appendChild(caseSubmit);
            caseDetails.appendChild(casePanel);
            card.appendChild(caseDetails);
          }
          if (isTeacher) {
            const caseDetails = document.createElement("details");
            caseDetails.className = "inline inline-details";
            const caseSummary = document.createElement("summary");
            caseSummary.className = "inline-summary";
            caseSummary.textContent = "症例文編集";
            caseDetails.appendChild(caseSummary);
            const casePanel = document.createElement("div");
            casePanel.className = "edit-panel";
            const caseArea = document.createElement("textarea");
            caseArea.rows = 3;
            caseArea.value = q.case_text || "";
            casePanel.appendChild(caseArea);
            const caseNote = document.createElement("input");
            caseNote.type = "text";
            caseNote.placeholder = "コメント（任意）";
            casePanel.appendChild(caseNote);
            const caseSubmit = document.createElement("button");
            caseSubmit.textContent = "症例文を反映";
            caseSubmit.addEventListener("click", () => {
              applyCaseTextOverride(q, caseArea.value, caseNote.value);
            });
            casePanel.appendChild(caseSubmit);
            caseDetails.appendChild(casePanel);
            card.appendChild(caseDetails);
            const caseProposals = buildProposalList(q, "case_text");
            if (caseProposals) card.appendChild(caseProposals);
          }

          const stem = document.createElement("div");
          stem.className = "stem";
          stem.textContent = q.stem || "";
          card.appendChild(stem);
          if (!isTeacher) {
            const stemDetails = document.createElement("details");
            stemDetails.className = "inline inline-details";
            stemDetails.classList.add("guest-report");
            const stemSummary = document.createElement("summary");
            stemSummary.className = "inline-summary";
            stemSummary.textContent = "問題文の誤りを報告";
            stemDetails.appendChild(stemSummary);
            const stemPanel = document.createElement("div");
            stemPanel.className = "edit-panel";
            const stemArea = document.createElement("textarea");
            stemArea.rows = 3;
            stemArea.value = q.stem || "";
            stemPanel.appendChild(stemArea);
            const stemNote = document.createElement("input");
            stemNote.type = "text";
            stemNote.placeholder = "コメント（必須）";
            stemPanel.appendChild(stemNote);
            const stemSubmit = document.createElement("button");
            stemSubmit.textContent = "提案を送信";
            stemSubmit.addEventListener("click", () => {
              submitGuestEditRequest(q.serial, "stem", { stem: stemArea.value }, stemNote.value);
            });
            stemPanel.appendChild(stemSubmit);
            stemDetails.appendChild(stemPanel);
            card.appendChild(stemDetails);
          }
          if (isTeacher) {
            const stemDetails = document.createElement("details");
            stemDetails.className = "inline inline-details";
            const stemSummary = document.createElement("summary");
            stemSummary.className = "inline-summary";
            stemSummary.textContent = "問題文編集";
            stemDetails.appendChild(stemSummary);
            const stemPanel = document.createElement("div");
            stemPanel.className = "edit-panel";
            const stemArea = document.createElement("textarea");
            stemArea.rows = 3;
            stemArea.value = q.stem || "";
            stemPanel.appendChild(stemArea);
            const stemNote = document.createElement("input");
            stemNote.type = "text";
            stemNote.placeholder = "コメント（任意）";
            stemPanel.appendChild(stemNote);
            const stemSubmit = document.createElement("button");
            stemSubmit.textContent = "問題文を反映";
            stemSubmit.addEventListener("click", () => {
              applyStemOverride(q, stemArea.value, stemNote.value);
            });
            stemPanel.appendChild(stemSubmit);
            stemDetails.appendChild(stemPanel);
            card.appendChild(stemDetails);
            const stemProposals = buildProposalList(q, "stem");
            if (stemProposals) card.appendChild(stemProposals);
          }

          const ul = document.createElement("ol");
          ul.className = "choices";
          const nums = ["１", "２", "３", "４", "５", "６", "７", "８", "９"];
          const answered = getSessionAnswered(q.serial);
          const correctIndices = getAnswerIndices(q);
          (q.choices || []).forEach((choice, idx) => {
            const li = document.createElement("li");
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "choice-btn";
            btn.textContent = choice;
            btn.setAttribute("aria-label", `選択肢${idx + 1} ${choice}`);
            if (answered) {
              btn.disabled = true;
              if (!q.answer_none && correctIndices.includes(idx + 1)) {
                btn.classList.add("correct");
              }
              if (q.answer_none && answered.selectedIndex === idx + 1) {
                btn.classList.add("correct");
              }
              if (answered.selectedIndex === idx + 1 && !answered.isCorrect) {
                btn.classList.add("incorrect");
              }
            }
            btn.addEventListener("click", () => {
              handleAnswerSelection(q, idx + 1, btn);
            });
            li.appendChild(btn);
            ul.appendChild(li);
          });
          card.appendChild(ul);
          if (!isTeacher) {
            const choiceDetails = document.createElement("details");
            choiceDetails.className = "inline inline-details";
            choiceDetails.classList.add("guest-report");
            const choiceSummary = document.createElement("summary");
            choiceSummary.className = "inline-summary";
            choiceSummary.textContent = "選択肢の誤りを報告";
            choiceDetails.appendChild(choiceSummary);
            const choicePanel = document.createElement("div");
            choicePanel.className = "edit-panel";
            const choiceInputs = buildChoiceInputs(q.choices || []);
            choicePanel.appendChild(choiceInputs.wrap);
            const choiceNote = document.createElement("input");
            choiceNote.type = "text";
            choiceNote.placeholder = "コメント（必須）";
            choicePanel.appendChild(choiceNote);
            const choiceSubmit = document.createElement("button");
            choiceSubmit.textContent = "提案を送信";
            choiceSubmit.addEventListener("click", () => {
              const next = getChoiceInputValues(choiceInputs.inputs);
              submitGuestEditRequest(q.serial, "choices", { choices: next }, choiceNote.value);
            });
            choicePanel.appendChild(choiceSubmit);
            choiceDetails.appendChild(choicePanel);
            card.appendChild(choiceDetails);
          }
          if (isTeacher) {
            const choiceDetails = document.createElement("details");
            choiceDetails.className = "inline inline-details";
            const choiceSummary = document.createElement("summary");
            choiceSummary.className = "inline-summary";
            choiceSummary.textContent = "選択肢編集";
            choiceDetails.appendChild(choiceSummary);
            const choicePanel = document.createElement("div");
            choicePanel.className = "edit-panel";
            const choiceInputs = buildChoiceInputs(q.choices || []);
            choicePanel.appendChild(choiceInputs.wrap);
            const choiceNote = document.createElement("input");
            choiceNote.type = "text";
            choiceNote.placeholder = "コメント（任意）";
            choicePanel.appendChild(choiceNote);
            const choiceSubmit = document.createElement("button");
            choiceSubmit.textContent = "選択肢を反映";
            choiceSubmit.addEventListener("click", () => {
              const next = getChoiceInputValues(choiceInputs.inputs);
              applyChoicesOverride(q, next, choiceNote.value);
            });
            choicePanel.appendChild(choiceSubmit);
            choiceDetails.appendChild(choicePanel);
            card.appendChild(choiceDetails);
            const choiceProposals = buildProposalList(q, "choices");
            if (choiceProposals) card.appendChild(choiceProposals);
          }

          const feedback = document.createElement("div");
          feedback.className = "choice-feedback";
          if (answered) {
            feedback.textContent = answered.isCorrect ? "正解" : "不正解";
          }
          card.appendChild(feedback);

          const tags = document.createElement("div");
          tags.className = "tagline";
          if (!state.showTags) tags.classList.add("is-hidden");
          const tagsLabel = document.createElement("span");
          tagsLabel.className = "tag-label";
          tagsLabel.textContent = "タグ:";
          tags.appendChild(tagsLabel);
          const tagList = q.tags || [];
          if (!tagList.length) {
            const span = document.createElement("span");
            span.textContent = "(なし)";
            tags.appendChild(span);
          } else {
            tagList.forEach(tag => {
              const link = document.createElement("button");
              link.className = "chip-link";
              link.textContent = tag;
              link.setAttribute("aria-label", `タグ ${tag} で絞り込み`);
              link.addEventListener("click", () => {
                applyFilters({ keyword: `#${tag}` });
              });
              tags.appendChild(link);
            });
          }
          if (!isTeacher) {
            const tagDetails = document.createElement("details");
            tagDetails.className = "inline inline-details";
            tagDetails.classList.add("guest-report");
            const tagSummary = document.createElement("summary");
            tagSummary.className = "inline-summary";
            tagSummary.textContent = "タグ修正を提案";
            tagDetails.appendChild(tagSummary);
            const tagPanel = document.createElement("div");
            tagPanel.className = "edit-panel";
            const tagRemoveWrap = document.createElement("div");
            (q.tags || []).forEach(tag => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = tag;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + tag));
              tagRemoveWrap.appendChild(lbl);
            });
            tagPanel.appendChild(tagRemoveWrap);
            const tagAdd = document.createElement("input");
            tagAdd.type = "text";
            tagAdd.placeholder = "追加タグ（カンマ区切り）";
            tagPanel.appendChild(tagAdd);
            const tagNote = document.createElement("input");
            tagNote.type = "text";
            tagNote.placeholder = "コメント（必須）";
            tagPanel.appendChild(tagNote);
            const tagSubmit = document.createElement("button");
            tagSubmit.textContent = "提案を送信";
            tagSubmit.addEventListener("click", () => {
              const remove = Array.from(tagRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = tagAdd.value.split(",").map(t => t.trim()).filter(Boolean);
              if (!add.length && !remove.length) {
                alert("追加または削除を入力してください。");
                return;
              }
              submitGuestEditRequest(q.serial, "tag", { add, remove }, tagNote.value);
            });
            tagPanel.appendChild(tagSubmit);
            tagDetails.appendChild(tagPanel);
            tags.appendChild(tagDetails);
          }
          if (isTeacher) {
            const tagDetails = document.createElement("details");
            tagDetails.className = "inline inline-details";
            const tagSummary = document.createElement("summary");
            tagSummary.className = "inline-summary";
            tagSummary.textContent = "タグ編集";
            tagDetails.appendChild(tagSummary);
            const tagPanel = document.createElement("div");
            tagPanel.className = "edit-panel";
            const tagRemoveWrap = document.createElement("div");
            (q.tags || []).forEach(tag => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = tag;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + tag));
              tagRemoveWrap.appendChild(lbl);
            });
            tagPanel.appendChild(tagRemoveWrap);
            const tagAdd = document.createElement("input");
            tagAdd.type = "text";
            tagAdd.placeholder = "追加タグ（カンマ区切り）";
            tagPanel.appendChild(tagAdd);
            const tagNote = document.createElement("input");
            tagNote.type = "text";
            tagNote.placeholder = "コメント（任意）";
            tagPanel.appendChild(tagNote);
            const tagSubmit = document.createElement("button");
            tagSubmit.textContent = "タグを反映";
            tagSubmit.addEventListener("click", () => {
              const remove = Array.from(tagRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = tagAdd.value.split(",").map(t => t.trim()).filter(Boolean);
              applyTagsOverride(q, add, remove, tagNote.value);
            });
            tagPanel.appendChild(tagSubmit);
            tagDetails.appendChild(tagPanel);
            tags.appendChild(tagDetails);
            const tagProposals = buildProposalList(q, "tag");
            if (tagProposals) tags.appendChild(tagProposals);
          }
          card.appendChild(tags);

          const subs = document.createElement("div");
          subs.className = "tagline";
          if (!state.showSubtopics) subs.classList.add("is-hidden");
          const subsLabel = document.createElement("span");
          subsLabel.className = "tag-label";
          subsLabel.textContent = "小項目:";
          subs.appendChild(subsLabel);
          const subList = q.subtopics || [];
          if (!subList.length) {
            const span = document.createElement("span");
            span.textContent = "(なし)";
            subs.appendChild(span);
          } else {
            subList.forEach(sub => {
              const link = document.createElement("button");
              link.className = "chip-link";
              link.textContent = sub;
              link.setAttribute("aria-label", `小項目 ${sub} で絞り込み`);
              link.addEventListener("click", () => {
                applyFilters({ subject: q.subject, subtopic: sub });
              });
              subs.appendChild(link);
            });
          }
          if (!isTeacher) {
            const subDetails = document.createElement("details");
            subDetails.className = "inline inline-details";
            subDetails.classList.add("guest-report");
            const subSummary = document.createElement("summary");
            subSummary.className = "inline-summary";
            subSummary.textContent = "小項目修正を提案";
            subDetails.appendChild(subSummary);
            const subPanel = document.createElement("div");
            subPanel.className = "edit-panel";
            const subRemoveWrap = document.createElement("div");
            (q.subtopics || []).forEach(name => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = name;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + name));
              subRemoveWrap.appendChild(lbl);
            });
            subPanel.appendChild(subRemoveWrap);
            const subSelect = document.createElement("select");
            subSelect.multiple = true;
            subSelect.style.width = "100%";
            const catalog = state.subtopicCatalog[q.subject] || [];
            catalog.forEach(name => {
              const opt = document.createElement("option");
              opt.value = name;
              opt.textContent = name;
              subSelect.appendChild(opt);
            });
            subPanel.appendChild(subSelect);
            const subNote = document.createElement("input");
            subNote.type = "text";
            subNote.placeholder = "コメント（必須）";
            subPanel.appendChild(subNote);
            const subSubmit = document.createElement("button");
            subSubmit.textContent = "提案を送信";
            subSubmit.addEventListener("click", () => {
              const remove = Array.from(subRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = Array.from(subSelect.selectedOptions).map(opt => opt.value);
              if (!add.length && !remove.length) {
                alert("追加または削除を入力してください。");
                return;
              }
              submitGuestEditRequest(q.serial, "subtopic", { add, remove }, subNote.value);
            });
            subPanel.appendChild(subSubmit);
            subDetails.appendChild(subPanel);
            subs.appendChild(subDetails);
          }
          if (isTeacher) {
            const subDetails = document.createElement("details");
            subDetails.className = "inline inline-details";
            const subSummary = document.createElement("summary");
            subSummary.className = "inline-summary";
            subSummary.textContent = "小項目編集";
            subDetails.appendChild(subSummary);
            const subPanel = document.createElement("div");
            subPanel.className = "edit-panel";
            const subRemoveWrap = document.createElement("div");
            (q.subtopics || []).forEach(name => {
              const lbl = document.createElement("label");
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.value = name;
              lbl.appendChild(cb);
              lbl.appendChild(document.createTextNode("削除: " + name));
              subRemoveWrap.appendChild(lbl);
            });
            subPanel.appendChild(subRemoveWrap);
            const subSelect = document.createElement("select");
            subSelect.multiple = true;
            subSelect.style.width = "100%";
            const catalog = state.subtopicCatalog[q.subject] || [];
            catalog.forEach(name => {
              const opt = document.createElement("option");
              opt.value = name;
              opt.textContent = name;
              subSelect.appendChild(opt);
            });
            subPanel.appendChild(subSelect);
            const subNote = document.createElement("input");
            subNote.type = "text";
            subNote.placeholder = "コメント（任意）";
            subPanel.appendChild(subNote);
            const subSubmit = document.createElement("button");
            subSubmit.textContent = "小項目を反映";
            subSubmit.addEventListener("click", () => {
              const remove = Array.from(subRemoveWrap.querySelectorAll("input:checked")).map(cb => cb.value);
              const add = Array.from(subSelect.selectedOptions).map(opt => opt.value);
              applySubtopicsOverride(q, add, remove, subNote.value);
            });
            subPanel.appendChild(subSubmit);
            subDetails.appendChild(subPanel);
            subs.appendChild(subDetails);
            const subProposals = buildProposalList(q, "subtopic");
            if (subProposals) subs.appendChild(subProposals);
          }
          card.appendChild(subs);

          const answer = document.createElement("div");
          answer.className = "answer";
          const label = formatAnswerLabel(q);
          answer.textContent = label ? `正答: ${label}` : "正答: 未登録";
          card.appendChild(answer);
          if (!isTeacher) {
            const answerDetails = document.createElement("details");
            answerDetails.className = "inline inline-details";
            answerDetails.classList.add("guest-report");
            const answerSummary = document.createElement("summary");
            answerSummary.className = "inline-summary";
            answerSummary.textContent = "模範解答の誤りを報告";
            answerDetails.appendChild(answerSummary);
            const answerPanel = document.createElement("div");
            answerPanel.className = "edit-panel";
            const selector = buildAnswerSelector(
              q.choices || [],
              getAnswerIndices(q),
              q.answer_none
            );
            answerPanel.appendChild(selector.wrap);
            const answerNote = document.createElement("input");
            answerNote.type = "text";
            answerNote.placeholder = "コメント（必須）";
            answerPanel.appendChild(answerNote);
            const answerSubmit = document.createElement("button");
            answerSubmit.textContent = "提案を送信";
            answerSubmit.addEventListener("click", () => {
              const value = selector.getValue();
              submitGuestEditRequest(q.serial, "answer", value, answerNote.value);
            });
            answerPanel.appendChild(answerSubmit);
            answerDetails.appendChild(answerPanel);
            card.appendChild(answerDetails);
          }
          if (isTeacher) {
            const answerDetails = document.createElement("details");
            answerDetails.className = "inline inline-details";
            const answerSummary = document.createElement("summary");
            answerSummary.className = "inline-summary";
            answerSummary.textContent = "模範解答編集";
            answerDetails.appendChild(answerSummary);
            const answerPanel = document.createElement("div");
            answerPanel.className = "edit-panel";
            const selector = buildAnswerSelector(
              q.choices || [],
              getAnswerIndices(q),
              q.answer_none
            );
            answerPanel.appendChild(selector.wrap);
            const answerNote = document.createElement("input");
            answerNote.type = "text";
            answerNote.placeholder = "コメント（任意）";
            answerPanel.appendChild(answerNote);
            const answerSubmit = document.createElement("button");
            answerSubmit.textContent = "模範解答を反映";
            answerSubmit.addEventListener("click", () => {
              const value = selector.getValue();
              applyAnswerOverride(q, value.answer_indices, value.answer_none, answerNote.value);
            });
            answerPanel.appendChild(answerSubmit);
            answerDetails.appendChild(answerPanel);
            card.appendChild(answerDetails);
            const answerProposals = buildProposalList(q, "answer");
            if (answerProposals) card.appendChild(answerProposals);
          }

          const explanation = document.createElement("div");
          explanation.className = "explanation";
          const expText = q.explanation_latest || "";
          const expLabel = formatExplanationLabel(q.explanation_latest_source);
          const expHeader = document.createElement("div");
          expHeader.className = "explanation-header";
          const expTitle = document.createElement("span");
          expTitle.textContent = expText ? `解説${expLabel}:` : "解説: (未登録)";
          expHeader.appendChild(expTitle);
          if (!isTeacher) {
            if (q.explanations && q.explanations.length > 1) {
              const select = document.createElement("select");
              select.setAttribute("aria-label", "解説バージョンを選択");
              const label = document.createElement("option");
              label.value = "";
              label.textContent = "解説バージョン";
              select.appendChild(label);
              q.explanations.forEach(item => {
                const opt = document.createElement("option");
                opt.value = JSON.stringify({ body: item.body, source: item.source || "" });
                opt.textContent = `v${item.version}`;
                select.appendChild(opt);
              });
              select.addEventListener("change", () => {
                if (select.value) {
                  try {
                    const data = JSON.parse(select.value);
                    const label = formatExplanationLabel(data.source);
                    expTitle.textContent = `解説${label}:`;
                    expBody.textContent = data.body || "";
                  } catch (err) {
                    expTitle.textContent = "解説:";
                    expBody.textContent = select.value || "";
                  }
                } else {
                  expTitle.textContent = expText ? `解説${expLabel}:` : "解説: (未登録)";
                  expBody.textContent = expText || "";
                }
              });
              expHeader.appendChild(select);
            }
            const expDetails = document.createElement("details");
            expDetails.className = "inline inline-details";
            expDetails.classList.add("guest-report");
            const expSummary = document.createElement("summary");
            expSummary.className = "inline-summary";
            expSummary.textContent = "解説修正を提案";
            expDetails.appendChild(expSummary);
            const expPanel = document.createElement("div");
            expPanel.className = "edit-panel";
            const expArea = document.createElement("textarea");
            expArea.rows = 4;
            expArea.value = expText || "";
            expPanel.appendChild(expArea);
            const expNote = document.createElement("input");
            expNote.type = "text";
            expNote.placeholder = "コメント（必須）";
            expPanel.appendChild(expNote);
            const expSubmit = document.createElement("button");
            expSubmit.textContent = "提案を送信";
            expSubmit.addEventListener("click", () => {
              if (!expArea.value.trim()) {
                alert("解説を入力してください。");
                return;
              }
              submitGuestEditRequest(
                q.serial,
                "explanation",
                { explanation: expArea.value },
                expNote.value
              );
            });
            expPanel.appendChild(expSubmit);
            expDetails.appendChild(expPanel);
            expHeader.appendChild(expDetails);
          }
          if (isTeacher) {
            const source = q.explanation_latest_source || "";
            const teacherLabel = formatExplanationLabel(source);
            expTitle.textContent = expText ? `解説${teacherLabel}:` : "解説: (未登録)";
            if (source === "llm_checked") {
              const expRevoke = document.createElement("button");
              expRevoke.textContent = "承認取消";
              expRevoke.addEventListener("click", () => {
                applyExplanationConfirm(q, "llm");
              });
              expHeader.appendChild(expRevoke);
            } else if (source !== "teacher" && source !== "human") {
              const expConfirm = document.createElement("button");
              expConfirm.textContent = "解説承認";
              expConfirm.addEventListener("click", () => {
                applyExplanationConfirm(q, "llm_checked");
              });
              expHeader.appendChild(expConfirm);
            }

            const expDetails = document.createElement("details");
            expDetails.className = "inline inline-details";
            const expSummary = document.createElement("summary");
            expSummary.className = "inline-summary";
            expSummary.textContent = "解説編集";
            expDetails.appendChild(expSummary);
            const expPanel = document.createElement("div");
            expPanel.className = "edit-panel";
            const expArea = document.createElement("textarea");
            expArea.rows = 4;
            expArea.value = expText || "";
            expPanel.appendChild(expArea);
            const expNote = document.createElement("input");
            expNote.type = "text";
            expNote.placeholder = "コメント（任意）";
            expPanel.appendChild(expNote);
            const expSubmit = document.createElement("button");
            expSubmit.textContent = "解説を反映";
            expSubmit.addEventListener("click", () => {
              applyExplanationEdit(q, expArea.value, expNote.value);
            });
            expPanel.appendChild(expSubmit);
            expDetails.appendChild(expPanel);
            expHeader.appendChild(expDetails);
            const expProposals = buildProposalList(q, "explanation");
            if (expProposals) explanation.appendChild(expProposals);
          }
          explanation.appendChild(expHeader);
          const expBody = document.createElement("div");
          expBody.className = "explanation-body";
          expBody.textContent = expText || "";
          explanation.appendChild(expBody);
          const stats =
            state.answerStatsBySerial[q.serial] ||
            (state.answerStatsLoaded.has("*") ? { count: 0, correct: 0 } : null);
          if (stats) {
            const statsEl = document.createElement("div");
            statsEl.className = "answer-stats";
            if (stats.count >= 5) {
              const rate = stats.count ? Math.round((stats.correct / stats.count) * 100) : 0;
              statsEl.textContent = `回答数: ${stats.count} / 正答数: ${stats.correct} / 正答率: ${rate}%`;
            } else {
              statsEl.textContent = `集計中（回答数: ${stats.count}）`;
            }
            explanation.appendChild(statsEl);
          }
          card.appendChild(explanation);

          const actions = document.createElement("div");
          actions.className = "card-actions";
          const copyBtn = document.createElement("button");
          copyBtn.textContent = "この問題をコピー";
          copyBtn.setAttribute("aria-label", "この問題をクリップボードにコピー");
          copyBtn.addEventListener("click", () => {
            const mode = getCopyMode();
            const text = formatQuestionForCopy(q, mode);
            copyToClipboard(text);
          });
          actions.appendChild(copyBtn);
          const deepDiveBtn = document.createElement("button");
          deepDiveBtn.textContent = "深掘りプロンプトをコピー";
          deepDiveBtn.setAttribute("aria-label", "深掘り用プロンプトをクリップボードにコピー");
          deepDiveBtn.addEventListener("click", () => {
            const text = formatDeepDivePrompt(q);
            copyToClipboard(text);
          });
          actions.appendChild(deepDiveBtn);
          const retryBtn = document.createElement("button");
          retryBtn.textContent = "再回答";
          retryBtn.className = "retry-btn";
          retryBtn.disabled = !answered;
          retryBtn.setAttribute("aria-label", "この問題を再回答する");
          retryBtn.addEventListener("click", () => {
            const scrollY = window.scrollY;
            clearSessionAnswer(q.serial);
            renderResults(filterQuestions());
            requestAnimationFrame(() => {
              window.scrollTo(0, scrollY);
            });
          });
          actions.appendChild(retryBtn);
          card.appendChild(actions);

          target.appendChild(card);
        }

        const subset = list;
        let idx = 0;
        const batchSize = 20;
        const more = document.createElement("button");
        const updateLabel = () => {
          more.textContent = `さらに表示 (${idx}/${subset.length})`;
        };
        function renderBatch(batch) {
          const frag = document.createDocumentFragment();
          batch.forEach(item => {
            appendCard(applyOverridesToQuestion(item), frag);
          });
          container.appendChild(frag);
        }
        async function renderChunk() {
          const end = Math.min(idx + batchSize, subset.length);
          const batch = subset.slice(idx, end);
          idx = end;
          more.disabled = true;
          const statsLoaded = state.answerStatsLoaded.has("*");
          await ensureOverridesLoaded(batch.map(item => item.serial));
          if (isTeacher) {
            await ensureEditRequestsLoaded(batch.map(item => item.serial));
          }
          await ensureAnswerStatsLoaded(batch.map(item => item.serial));
          if (isStatSort && !statsLoaded && state.answerStatsLoaded.has("*")) {
            renderResults(filterQuestions());
            return;
          }
          renderBatch(batch);
          more.disabled = false;
          updateLabel();
          if (idx >= subset.length) {
            more.remove();
          }
        }

        renderChunk();
        if (idx < subset.length) {
          updateLabel();
          more.addEventListener("click", () => {
            renderChunk();
          });
          moreContainer.appendChild(more);
        }
      }

      function init() {
        loadAnsweredState();
        loadTagVisibility();
        loadSubtopicCatalog();
        const updateInfo = document.getElementById("updateInfo");
        const updateMoreBtn = document.getElementById("updateMoreBtn");
        loadUserReadme();
        loadUpdateLog().then(() => {
          if (updateInfo && updateInfo.open) {
            renderUpdateLog(3);
          }
        });
        Promise.all([loadData(), loadDisabledTags()]).then(() => {
          computeFrequentScores();
          populateSelect(
            document.getElementById("subjectSelect"),
            Object.keys(state.indexBySubject)
          );
          updateSubtopicOptions("");
          renderResults(filterQuestions());
        });

        initAuthUI();
        if (updateInfo) {
          updateInfo.addEventListener("toggle", () => {
            if (updateInfo.open) {
              renderUpdateLog(3);
            }
          });
        }
        if (updateMoreBtn) {
          updateMoreBtn.addEventListener("click", () => {
            renderUpdateLog(state.updateShown + 3);
          });
        }

        initHistoryPanel();
        initProposalPanel();
        initTagDisablePanel();

        document.getElementById("searchBtn").addEventListener("click", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("resetBtn").addEventListener("click", () => {
          document.getElementById("keyword").value = "";
          document.getElementById("subjectSelect").value = "";
          document.getElementById("examTypeSelect").value = "";
          document.getElementById("sessionFrom").value = "";
          document.getElementById("sessionTo").value = "";
          document.getElementById("sortSession").value = "desc";
          document.getElementById("showAnswered").checked = false;
          document.getElementById("hasExplanation").checked = false;
          document.getElementById("hasTags").checked = false;
          document.getElementById("hasSubtopics").checked = false;
          document.getElementById("onlyFrequent").checked = false;
          updateSubtopicOptions("");
          renderResults(filterQuestions());
        });
        document.getElementById("subjectSelect").addEventListener("change", (e) => {
          updateSubtopicOptions(e.target.value);
          renderResults(filterQuestions());
        });
        document.getElementById("subtopicSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("examTypeSelect").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sessionFrom").addEventListener("input", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sessionTo").addEventListener("input", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("sortSession").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("showAnswered").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("showTagsToggle").addEventListener("change", (e) => {
          state.showTags = e.target.checked;
          saveTagVisibility();
          renderResults(filterQuestions());
        });
        document.getElementById("showSubtopicsToggle").addEventListener("change", (e) => {
          state.showSubtopics = e.target.checked;
          saveTagVisibility();
          renderResults(filterQuestions());
        });
        document.getElementById("hasExplanation").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasTags").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("hasSubtopics").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("onlyFrequent").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("toggleAnswer").addEventListener("change", () => {
          renderResults(filterQuestions());
        });
        document.getElementById("toggleExplanation").addEventListener("change", () => {
          renderResults(filterQuestions());
        });

        const reportModeToggle = document.getElementById("reportModeToggle");
        if (reportModeToggle) {
          reportModeToggle.addEventListener("change", () => {
            state.reportMode = reportModeToggle.checked;
            document.body.classList.toggle("report-mode", state.reportMode);
          });
          reportModeToggle.checked = false;
          document.body.classList.remove("report-mode");
        }

      document.getElementById("copyAllBtn").addEventListener("click", async () => {
        const list = filterQuestions();
        await ensureOverridesLoaded(list.map(item => item.serial));
        const header = buildFilterHeader();
        const mode = getCopyMode();
        const body = list.map(q => formatQuestionForCopy(applyOverridesToQuestion(q), mode)).join("\n\n");
        copyToClipboard(`${header}\n\n${body}`.trim());
      });

      document.getElementById("resetAnswersBtn").addEventListener("click", () => {
        if (!confirm("回答履歴をリセットしますか？")) {
          return;
        }
        state.answeredMap = {};
        clearSessionAnswer();
        localStorage.removeItem("answeredSerials");
        renderResults(filterQuestions());
      });

        document.getElementById("keyword").addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            renderResults(filterQuestions());
          }
        });

        document.addEventListener("keydown", (e) => {
          const active = document.activeElement;
          const isInput =
            active &&
            (active.tagName === "INPUT" ||
              active.tagName === "TEXTAREA" ||
              active.tagName === "SELECT");
          if (isInput && e.key !== "Escape") {
            return;
          }
          if (e.key === "/") {
            e.preventDefault();
            document.getElementById("keyword").focus();
          } else if (e.key === "s") {
            document.getElementById("subjectSelect").focus();
          } else if (e.key === "u") {
            document.getElementById("subtopicSelect").focus();
          } else if (e.key === "f") {
            renderResults(filterQuestions());
          } else if (e.key === "r") {
            document.getElementById("resetBtn").click();
          } else if (e.key === "a") {
            const toggle = document.getElementById("toggleAnswer");
            toggle.checked = !toggle.checked;
            renderResults(filterQuestions());
          } else if (e.key === "e") {
            const toggle = document.getElementById("toggleExplanation");
            toggle.checked = !toggle.checked;
            renderResults(filterQuestions());
          }
        });
      }

      init();

      function sendReport(serial, kind, button, comment) {
        const anonId = getAnonId();
        if (supabaseClient) {
          supabaseClient
            .from("feedback")
            .insert([{ serial, kind, anon_id: anonId, comment: comment }])
            .then(({ error }) => {
              if (error) {
                button.classList.remove("reported");
                console.warn("報告に失敗しました。", error);
                return;
              }
              button.classList.add("reported");
            });
          return;
        }
        fetch(
          `${API_BASE}/api/report?serial=${encodeURIComponent(serial)}&kind=${encodeURIComponent(kind)}&comment=${encodeURIComponent(comment || "")}`,
          { mode: "cors" }
        )
          .then(resp => resp.json())
          .then(data => {
            if (data.message && data.message.startsWith("報告しました")) {
              button.classList.add("reported");
            } else {
              button.classList.remove("reported");
              console.warn(data.message || "報告に失敗しました。");
            }
          })
          .catch(err => {
            button.classList.remove("reported");
            console.warn("報告に失敗しました。", err);
          });
      }

      function initAuthUI() {
        const status = document.getElementById("authStatus");
        const form = document.getElementById("authForm");
        const actions = document.getElementById("authActions");
        const message = document.getElementById("authMessage");
        const emailInput = document.getElementById("authEmail");
        const passwordInput = document.getElementById("authPassword");
        const loginBtn = document.getElementById("authLoginBtn");
        const logoutBtn = document.getElementById("authLogoutBtn");
        const toggleBtn = document.getElementById("authToggleBtn");
        const panel = document.getElementById("teacherAuth");
        const historyPanel = document.getElementById("historyPanel");
        const reportModeWrap = document.getElementById("reportModeWrap");
        const reportModeToggle = document.getElementById("reportModeToggle");

        if (!supabaseClient) {
          status.textContent = "Supabase未設定";
          form.hidden = true;
          panel.hidden = true;
          toggleBtn.hidden = true;
          if (historyPanel) historyPanel.hidden = true;
          if (reportModeWrap) reportModeWrap.hidden = true;
          return;
        }

        toggleBtn.addEventListener("click", () => {
          const next = panel.hidden;
          panel.hidden = !next ? true : false;
          toggleBtn.setAttribute("aria-expanded", next ? "true" : "false");
        });

        supabaseClient.auth.getSession().then(({ data }) => {
          updateAuthUI(data.session);
        });
        supabaseClient.auth.onAuthStateChange((_event, session) => {
          updateAuthUI(session);
        });

        loginBtn.addEventListener("click", async () => {
          const email = emailInput.value.trim();
          const password = passwordInput.value;
          message.textContent = "";
          if (!email || !password) {
            message.textContent = "メールとパスワードを入力してください。";
            return;
          }
          const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
          if (error || !data || !data.session) {
            message.textContent = "ログインに失敗しました。";
            return;
          }
          const user = data.session.user;
          if (!isTeacherUser(user)) {
            message.textContent = "教師権限がありません。";
            await supabaseClient.auth.signOut();
            return;
          }
          message.textContent = "ログインしました。";
        });

        const signupBtn = document.getElementById("signupBtn");
        const signupEmail = document.getElementById("signupEmail");
        const signupPassword = document.getElementById("signupPassword");
        const signupPasswordConfirm = document.getElementById("signupPasswordConfirm");
        const signupNote = document.getElementById("signupNote");
        if (signupBtn) {
          signupBtn.addEventListener("click", async () => {
            const email = signupEmail ? signupEmail.value.trim() : "";
            const password = signupPassword ? signupPassword.value : "";
            const passwordConfirm = signupPasswordConfirm ? signupPasswordConfirm.value : "";
            const note = signupNote ? signupNote.value.trim() : "";
            message.textContent = "";
            if (!email || !password) {
              message.textContent = "メールとパスワードを入力してください。";
              return;
            }
            if (password !== passwordConfirm) {
              message.textContent = "パスワードが一致しません。";
              return;
            }
            const { data, error } = await supabaseClient.auth.signUp({ email, password });
            if (error) {
              message.textContent = "申請に失敗しました。";
              return;
            }
            const user = data && data.user ? data.user : null;
            if (!user) {
              message.textContent = "申請を受け付けました。確認メール後に再度申請してください。";
              return;
            }
            const { error: insertError } = await supabaseClient
              .from("teacher_requests")
              .insert([
                {
                  user_id: user.id,
                  email: email,
                  note: note,
                  status: "pending"
                }
              ]);
            if (insertError) {
              message.textContent = "申請の登録に失敗しました。";
              return;
            }
            await supabaseClient.auth.signOut();
            message.textContent = "申請を受け付けました。承認後にログインできます。";
            if (signupPassword) signupPassword.value = "";
            if (signupPasswordConfirm) signupPasswordConfirm.value = "";
          });
        }

        logoutBtn.addEventListener("click", async () => {
          message.textContent = "";
          const { error } = await supabaseClient.auth.signOut();
          if (error) {
            message.textContent = "ログアウトに失敗しました。";
            return;
          }
          message.textContent = "ログアウトしました。";
        });

        function isTeacherUser(user) {
          return (user?.app_metadata?.role || user?.user_metadata?.role || "") === "teacher";
        }

      function updateAuthUI(session) {
        const user = session && session.user ? session.user : null;
        state.editRequestsBySerial = {};
        state.editRequestsLoaded = new Set();
        const proposalPanel = document.getElementById("proposalPanel");
        const tagDisablePanel = document.getElementById("tagDisablePanel");
        if (user && !isTeacherUser(user)) {
          state.teacherSession = null;
          status.textContent = "教師権限がありません。";
          form.hidden = false;
          actions.hidden = true;
          toggleBtn.textContent = "教師ログイン";
          toggleBtn.setAttribute("aria-label", "教師ログイン");
          message.textContent = "教師アカウントでログインしてください。";
          if (historyPanel) historyPanel.hidden = true;
          if (proposalPanel) proposalPanel.hidden = true;
          if (tagDisablePanel) tagDisablePanel.hidden = true;
          if (reportModeWrap) reportModeWrap.hidden = false;
          supabaseClient.auth.signOut();
          return;
        }
        state.teacherSession = user ? session : null;
        if (user) {
            if (state.teacherUserId !== user.id) {
              const answerToggle = document.getElementById("toggleAnswer");
              const explanationToggle = document.getElementById("toggleExplanation");
              if (answerToggle) answerToggle.checked = false;
              if (explanationToggle) explanationToggle.checked = true;
              state.teacherUserId = user.id;
            }
            status.textContent = `ログイン中: ${user.email}`;
            form.hidden = true;
            actions.hidden = false;
            toggleBtn.textContent = "教師ログイン（ログイン中）";
            toggleBtn.setAttribute("aria-label", "教師ログイン（ログイン中）");
            if (historyPanel) historyPanel.hidden = false;
            if (proposalPanel) proposalPanel.hidden = false;
            if (tagDisablePanel) tagDisablePanel.hidden = false;
            if (reportModeWrap) reportModeWrap.hidden = true;
            state.reportMode = false;
            if (reportModeToggle) reportModeToggle.checked = false;
            document.body.classList.remove("report-mode");
          } else {
            state.teacherUserId = null;
            status.textContent = "未ログイン";
            form.hidden = false;
            actions.hidden = true;
            toggleBtn.textContent = "教師ログイン";
            toggleBtn.setAttribute("aria-label", "教師ログイン");
            if (historyPanel) historyPanel.hidden = true;
            if (proposalPanel) proposalPanel.hidden = true;
            if (tagDisablePanel) tagDisablePanel.hidden = true;
            if (reportModeWrap) reportModeWrap.hidden = false;
          }
          renderResults(filterQuestions());
        }
      }

      function submitEditRequest(serial, kind, payload, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const body = {
          serial: serial,
          kind: kind,
          payload: payload || {},
          note: note || "",
          status: "open",
          created_by: session.user.id,
          created_email: session.user.email
        };
        supabaseClient
          .from("edit_requests")
          .insert([body])
          .then(({ error }) => {
            if (error) {
              alert("送信に失敗しました。");
              return;
            }
            alert("編集提案を送信しました。");
          });
      }

      function submitGuestEditRequest(serial, kind, payload, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        if (!note || !note.trim()) {
          alert("コメントを入力してください。");
          return;
        }
        const body = {
          serial: serial,
          kind: kind,
          payload: payload || {},
          note: note.trim(),
          status: "open",
          created_by: getAnonId(),
          created_email: "guest"
        };
        supabaseClient
          .from("edit_requests")
          .insert([body])
          .then(({ error }) => {
            if (error) {
              alert("送信に失敗しました。");
              return;
            }
            alert("提案を送信しました。");
          });
      }

      function updateEditRequestStatus(id, status) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return Promise.resolve(false);
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return Promise.resolve(false);
        }
        return supabaseClient
          .from("edit_requests")
          .update({ status: status })
          .eq("id", id)
          .then(({ error }) => {
            if (error) {
              alert("更新に失敗しました。");
              return false;
            }
            Object.keys(state.editRequestsBySerial).forEach(serial => {
              state.editRequestsBySerial[serial] = (state.editRequestsBySerial[serial] || []).filter(
                item => item.id !== id
              );
            });
            renderResults(filterQuestions());
            return true;
          });
      }

      function applyTagsOverride(question, add, remove, note) {
        const before = { tags: question.tags || [] };
        const next = Array.from(
          new Set([...(question.tags || []), ...add].filter(tag => !remove.includes(tag)))
        );
        const after = { tags: next };
        return applyOverrideChange(question.serial, "tags", before, after, { tags: next }, note);
      }

      function applySubtopicsOverride(question, add, remove, note) {
        const before = { subtopics: question.subtopics || [] };
        const next = Array.from(
          new Set([...(question.subtopics || []), ...add].filter(name => !remove.includes(name)))
        );
        const after = { subtopics: next };
        return applyOverrideChange(question.serial, "subtopics", before, after, { subtopics: next }, note);
      }

      function applyExplanationConfirm(question, nextSource) {
        const current = question.explanation_latest_source || "";
        const normalized = nextSource || (current === "llm" || current === "ai" ? "llm_checked" : "llm_checked");
        const before = { explanation_source: current };
        const after = { explanation_source: normalized };
        return applyOverrideChange(
          question.serial,
          "explanation",
          before,
          after,
          { explanation_source: normalized }
        );
      }

      function applyExplanationEdit(question, body, note) {
        const before = {
          explanation: question.explanation_latest || "",
          explanation_source: question.explanation_latest_source || ""
        };
        const after = {
          explanation: body,
          explanation_source: "teacher"
        };
        return applyOverrideChange(
          question.serial,
          "explanation",
          before,
          after,
          { explanation: body, explanation_source: "teacher" },
          note
        );
      }

      function applyCaseTextOverride(question, body, note) {
        const before = { case_text: question.case_text || "" };
        const after = { case_text: body || "" };
        return applyOverrideChange(
          question.serial,
          "case_text",
          before,
          after,
          { case_text: body || "" },
          note
        );
      }

      function applyStemOverride(question, body, note) {
        const before = { stem: question.stem || "" };
        const after = { stem: body || "" };
        return applyOverrideChange(
          question.serial,
          "stem",
          before,
          after,
          { stem: body || "" },
          note
        );
      }

      function applyChoicesOverride(question, choices, note) {
        const before = { choices: question.choices || [] };
        const next = Array.isArray(choices) ? choices : [];
        const after = { choices: next };
        return applyOverrideChange(
          question.serial,
          "choices",
          before,
          after,
          { choices: next },
          note
        );
      }

      function applyAnswerOverride(question, answerIndices, answerNone, note) {
        const before = {
          answer_indices: getAnswerIndices(question),
          answer_none: Boolean(question.answer_none)
        };
        const indices = Array.isArray(answerIndices)
          ? answerIndices.map(Number).filter(n => Number.isFinite(n))
          : [];
        const normalizedNone = Boolean(answerNone);
        const after = {
          answer_indices: normalizedNone ? [] : indices,
          answer_none: normalizedNone
        };
        return applyOverrideChange(
          question.serial,
          "answer",
          before,
          after,
          {
            answer_indices: after.answer_indices,
            answer_index: after.answer_indices[0] || null,
            answer_none: after.answer_none
          },
          note
        );
      }

      function applyOverrideChange(serial, kind, beforeData, afterData, patch, note) {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return Promise.resolve(false);
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return Promise.resolve(false);
        }
        const payload = {
          serial,
          updated_at: new Date().toISOString(),
          updated_by: session.user.id,
          synced_at: null,
          ...patch
        };
        const history = {
          serial,
          kind,
          before_data: beforeData,
          after_data: afterData,
          approved_by: session.user.id
        };
        return supabaseClient
          .from("question_overrides")
          .upsert(payload, { onConflict: "serial" })
          .then(({ error }) => {
            if (error) {
              alert(`反映に失敗しました: ${error.message}`);
              return false;
            }
            return supabaseClient
              .from("override_history")
              .insert([history])
              .then(({ error: historyError }) => {
                if (historyError) {
                  alert(`履歴の保存に失敗しました: ${historyError.message}`);
                  return false;
                }
                const existing = state.overridesBySerial[serial] || {};
                state.overridesBySerial[serial] = { ...existing, ...patch };
                state.overridesLoaded.add(serial);
                const base = state.questions.find(item => item.serial === serial);
                if (base) {
                  if (Object.prototype.hasOwnProperty.call(patch, "explanation")) {
                    base.explanation_latest = patch.explanation;
                  }
                  if (Object.prototype.hasOwnProperty.call(patch, "explanation_source")) {
                    base.explanation_latest_source = patch.explanation_source;
                  }
                if (Object.prototype.hasOwnProperty.call(patch, "tags")) {
                  base.tags = patch.tags;
                }
                if (Object.prototype.hasOwnProperty.call(patch, "subtopics")) {
                  base.subtopics = patch.subtopics;
                }
                if (Object.prototype.hasOwnProperty.call(patch, "case_text")) {
                  base.case_text = patch.case_text;
                }
                if (Object.prototype.hasOwnProperty.call(patch, "stem")) {
                  base.stem = patch.stem;
                }
                if (Object.prototype.hasOwnProperty.call(patch, "choices")) {
                  base.choices = patch.choices;
                }
                if (Object.prototype.hasOwnProperty.call(patch, "answer_indices")) {
                  base.answer_indices = patch.answer_indices;
                }
                if (Object.prototype.hasOwnProperty.call(patch, "answer_index")) {
                  base.answer_index = patch.answer_index;
                }
                if (Object.prototype.hasOwnProperty.call(patch, "answer_none")) {
                  base.answer_none = patch.answer_none;
                }
              }
                const scrollY = window.scrollY;
                renderResults(filterQuestions());
                requestAnimationFrame(() => {
                  window.scrollTo(0, scrollY);
                });
                return true;
              });
          });
      }

      async function ensureOverridesLoaded(serials) {
        if (!supabaseClient || !serials.length) return;
        const pending = serials.filter(serial => !state.overridesLoaded.has(serial));
        if (!pending.length) return;
        const chunkSize = 100;
        for (let i = 0; i < pending.length; i += chunkSize) {
          const chunk = pending.slice(i, i + chunkSize);
          const { data, error } = await supabaseClient
            .from("question_overrides")
            .select(
              "serial, explanation, explanation_source, tags, subtopics, case_text, stem, choices, answer_indices, answer_index, answer_none"
            )
            .in("serial", chunk)
            .is("synced_at", null);
          if (error) {
            console.warn("差分の取得に失敗しました。", error);
            return;
          }
          const map = {};
          (data || []).forEach(row => {
            map[row.serial] = row;
          });
          chunk.forEach(serial => {
            state.overridesBySerial[serial] = map[serial] || null;
            state.overridesLoaded.add(serial);
          });
          (data || []).forEach(row => {
            const base = state.questions.find(item => item.serial === row.serial);
            if (!base) return;
            if (row.explanation !== null && row.explanation !== undefined) {
              base.explanation_latest = row.explanation;
            }
            if (row.explanation_source !== null && row.explanation_source !== undefined) {
              base.explanation_latest_source = row.explanation_source;
            }
            if (row.tags !== null && row.tags !== undefined) {
              base.tags = row.tags;
            }
            if (row.subtopics !== null && row.subtopics !== undefined) {
              base.subtopics = row.subtopics;
            }
            if (row.case_text !== null && row.case_text !== undefined) {
              base.case_text = row.case_text;
            }
            if (row.stem !== null && row.stem !== undefined) {
              base.stem = row.stem;
            }
            if (row.choices !== null && row.choices !== undefined) {
              base.choices = row.choices;
            }
            if (row.answer_indices !== null && row.answer_indices !== undefined) {
              base.answer_indices = row.answer_indices;
            }
            if (row.answer_index !== null && row.answer_index !== undefined) {
              base.answer_index = row.answer_index;
            }
            if (row.answer_none !== null && row.answer_none !== undefined) {
              base.answer_none = row.answer_none;
            }
          });
        }
      }

      async function ensureEditRequestsLoaded(serials) {
        if (!supabaseClient || !serials.length) return;
        const session = state.teacherSession;
        if (!session || !session.user) return;
        const pending = serials.filter(serial => !state.editRequestsLoaded.has(serial));
        if (!pending.length) return;
        const chunkSize = 100;
        for (let i = 0; i < pending.length; i += chunkSize) {
          const chunk = pending.slice(i, i + chunkSize);
          const { data, error } = await supabaseClient
            .from("edit_requests")
            .select("id, serial, kind, payload, note, created_at, created_by, created_email, status")
            .in("serial", chunk)
            .eq("status", "open");
          if (error) {
            console.warn("編集提案の取得に失敗しました。", error);
            chunk.forEach(serial => {
              state.editRequestsBySerial[serial] = [];
              state.editRequestsLoaded.add(serial);
            });
            continue;
          }
          const map = {};
          (data || []).forEach(row => {
            if (!map[row.serial]) map[row.serial] = [];
            map[row.serial].push(row);
          });
          chunk.forEach(serial => {
            state.editRequestsBySerial[serial] = map[serial] || [];
            state.editRequestsLoaded.add(serial);
          });
        }
      }

      async function ensureAnswerStatsLoaded(serials) {
        if (!supabaseClient || !serials.length) return;
        if (state.answerStatsLoaded.has("*")) return;
        const pending = serials.filter(serial => !state.answerStatsLoaded.has(serial));
        if (!pending.length) return;
        const chunkSize = 100;
        for (let i = 0; i < pending.length; i += chunkSize) {
          const chunk = pending.slice(i, i + chunkSize);
          const { data, error } = await supabaseClient
            .from("answers")
            .select("serial, is_correct, anon_id, created_at");
          if (error) {
            console.warn("回答集計の取得に失敗しました。", error);
            chunk.forEach(serial => {
              state.answerStatsBySerial[serial] = { count: 0, correct: 0 };
              state.answerStatsLoaded.add(serial);
            });
            continue;
          }
          const stats = {};
          const latestByKey = {};
          (data || []).forEach(row => {
            const serial = row.serial;
            if (!serial) return;
            const anon = row.anon_id || "";
            const created = row.created_at || "";
            const day = created ? created.slice(0, 10) : "unknown";
            const key = `${serial}|${anon}|${day}`;
            const existing = latestByKey[key];
            if (!existing || created > existing.created_at) {
              latestByKey[key] = row;
            }
          });
          Object.values(latestByKey).forEach(row => {
            if (!stats[row.serial]) {
              stats[row.serial] = { count: 0, correct: 0 };
            }
            stats[row.serial].count += 1;
            if (row.is_correct) {
              stats[row.serial].correct += 1;
            }
          });
          Object.keys(stats).forEach(serial => {
            state.answerStatsBySerial[serial] = stats[serial];
          });
          chunk.forEach(serial => {
            if (!state.answerStatsBySerial[serial]) {
              state.answerStatsBySerial[serial] = { count: 0, correct: 0 };
            }
            state.answerStatsLoaded.add(serial);
          });
          state.answerStatsLoaded.add("*");
        }
      }

      function applyOverridesToQuestion(q) {
        const merged = { ...q };
        const override = state.overridesBySerial[q.serial];
        if (!override) {
          merged.tags = filterDisabledTags(merged.tags || []);
          return merged;
        }
        if (override.explanation !== undefined && override.explanation !== null) {
          merged.explanation_latest = override.explanation;
          merged.explanation_latest_source =
            override.explanation_source || merged.explanation_latest_source;
        }
        if (override.tags !== undefined && override.tags !== null) {
          merged.tags = override.tags;
        }
        if (override.subtopics !== undefined && override.subtopics !== null) {
          merged.subtopics = override.subtopics;
        }
        if (override.case_text !== undefined && override.case_text !== null) {
          merged.case_text = override.case_text;
        }
        if (override.stem !== undefined && override.stem !== null) {
          merged.stem = override.stem;
        }
        if (override.choices !== undefined && override.choices !== null) {
          merged.choices = override.choices;
        }
        if (override.answer_indices !== undefined && override.answer_indices !== null) {
          merged.answer_indices = override.answer_indices;
        }
        if (override.answer_index !== undefined && override.answer_index !== null) {
          merged.answer_index = override.answer_index;
        }
        if (override.answer_none !== undefined && override.answer_none !== null) {
          merged.answer_none = override.answer_none;
        }
        merged.tags = filterDisabledTags(merged.tags || []);
        return merged;
      }

      function getOpenEditRequests(serial, kind) {
        const list = state.editRequestsBySerial[serial] || [];
        return list.filter(item => item.kind === kind);
      }

      function buildProposalList(question, kind) {
        const items = getOpenEditRequests(question.serial, kind);
        if (!items.length) return null;
        const wrap = document.createElement("div");
        wrap.className = "proposal-list";
        const title = document.createElement("div");
        title.textContent = "提案";
        wrap.appendChild(title);

        items.forEach(item => {
          const entry = document.createElement("div");
          entry.className = "proposal-item";
          const meta = document.createElement("div");
          const when = item.created_at ? new Date(item.created_at).toLocaleString() : "";
          meta.textContent = when ? `日時: ${when}` : "日時: (不明)";
          entry.appendChild(meta);

          const payload = item.payload || {};
          if (kind === "tag" || kind === "subtopic") {
            const add = Array.isArray(payload.add) ? payload.add : [];
            const remove = Array.isArray(payload.remove) ? payload.remove : [];
            const addLine = document.createElement("div");
            const addLabel = document.createElement("span");
            addLabel.className = "proposal-label";
            addLabel.textContent = "追加:";
            addLine.appendChild(addLabel);
            addLine.appendChild(document.createTextNode(add.join(", ") || "(なし)"));
            entry.appendChild(addLine);
            const removeLine = document.createElement("div");
            const removeLabel = document.createElement("span");
            removeLabel.className = "proposal-label";
            removeLabel.textContent = "削除:";
            removeLine.appendChild(removeLabel);
            removeLine.appendChild(document.createTextNode(remove.join(", ") || "(なし)"));
            entry.appendChild(removeLine);
          }
          if (kind === "explanation") {
            const body = payload.explanation || payload.body || "";
            const bodyEl = document.createElement("div");
            bodyEl.textContent = body;
            entry.appendChild(bodyEl);
          }
          if (kind === "case_text") {
            const body = payload.case_text || "";
            const bodyEl = document.createElement("div");
            bodyEl.textContent = body;
            entry.appendChild(bodyEl);
          }
          if (kind === "stem") {
            const body = payload.stem || "";
            const bodyEl = document.createElement("div");
            bodyEl.textContent = body;
            entry.appendChild(bodyEl);
          }
          if (kind === "choices") {
            const list = document.createElement("div");
            const choices = Array.isArray(payload.choices) ? payload.choices : [];
            list.textContent = choices.join(" / ");
            entry.appendChild(list);
          }
          if (kind === "answer") {
            const label = formatAnswerLabelFrom(payload);
            const bodyEl = document.createElement("div");
            bodyEl.textContent = label ? `模範解答: ${label}` : "模範解答: (未入力)";
            entry.appendChild(bodyEl);
          }

          if (item.note) {
            const note = document.createElement("div");
            const noteLabel = document.createElement("span");
            noteLabel.className = "proposal-label";
            noteLabel.textContent = "コメント:";
            note.appendChild(noteLabel);
            note.appendChild(document.createTextNode(item.note));
            entry.appendChild(note);
          }

          const actions = document.createElement("div");
          actions.className = "proposal-actions";
          const applyBtn = document.createElement("button");
          applyBtn.textContent = "提案を反映";
          applyBtn.addEventListener("click", () => {
            if (kind === "tag") {
              const add = Array.isArray(payload.add) ? payload.add : [];
              const remove = Array.isArray(payload.remove) ? payload.remove : [];
              applyTagsOverride(question, add, remove, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
              return;
            }
            if (kind === "subtopic") {
              const add = Array.isArray(payload.add) ? payload.add : [];
              const remove = Array.isArray(payload.remove) ? payload.remove : [];
              applySubtopicsOverride(question, add, remove, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
              return;
            }
            if (kind === "explanation") {
              const body = payload.explanation || payload.body || "";
              if (!body.trim()) {
                alert("提案された解説が空です。");
                return;
              }
              applyExplanationEdit(question, body, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
            }
            if (kind === "case_text") {
              const body = payload.case_text || "";
              applyCaseTextOverride(question, body, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
            }
            if (kind === "stem") {
              const body = payload.stem || "";
              applyStemOverride(question, body, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
            }
            if (kind === "choices") {
              const next = Array.isArray(payload.choices) ? payload.choices : [];
              applyChoicesOverride(question, next, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
            }
            if (kind === "answer") {
              const indices = Array.isArray(payload.answer_indices) ? payload.answer_indices : [];
              const answerNone = Boolean(payload.answer_none);
              applyAnswerOverride(question, indices, answerNone, item.note || "").then(ok => {
                if (ok) updateEditRequestStatus(item.id, "applied");
              });
            }
          });
          actions.appendChild(applyBtn);
          const rejectBtn = document.createElement("button");
          rejectBtn.textContent = "提案を却下";
          rejectBtn.addEventListener("click", () => {
            updateEditRequestStatus(item.id, "rejected");
          });
          actions.appendChild(rejectBtn);
          entry.appendChild(actions);
          wrap.appendChild(entry);
        });
        return wrap;
      }

      function initHistoryPanel() {
        const fetchBtn = document.getElementById("historyFetchBtn");
        if (!fetchBtn) return;
        fetchBtn.addEventListener("click", () => {
          fetchHistory();
        });
      }

      function initProposalPanel() {
        const fetchBtn = document.getElementById("proposalFetchBtn");
        if (!fetchBtn) return;
        fetchBtn.addEventListener("click", () => {
          fetchProposals();
        });
      }

      async function fetchHistory() {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const serialInput = document.getElementById("historySerial");
        const kindSelect = document.getElementById("historyKind");
        const serial = serialInput ? serialInput.value.trim() : "";
        const kind = kindSelect ? kindSelect.value : "";
        let query = supabaseClient
          .from("override_history")
          .select("id, serial, kind, before_data, after_data, created_at")
          .order("created_at", { ascending: false })
          .limit(50);
        if (serial) {
          query = query.eq("serial", serial);
        }
        if (kind) {
          query = query.eq("kind", kind);
        }
        const { data, error } = await query;
        if (error) {
          alert("履歴の取得に失敗しました。");
          return;
        }
        renderHistoryList(data || []);
      }

      async function fetchProposals() {
        if (!supabaseClient) {
          alert("Supabaseが設定されていません。");
          return;
        }
        const session = state.teacherSession;
        if (!session || !session.user) {
          alert("教師ログインが必要です。");
          return;
        }
        const serialInput = document.getElementById("proposalSerial");
        const statusSelect = document.getElementById("proposalStatus");
        const serial = serialInput ? serialInput.value.trim() : "";
        const status = statusSelect ? statusSelect.value : "open";
        let query = supabaseClient
          .from("edit_requests")
          .select("id, serial, kind, payload, note, created_at, status, created_email, created_by")
          .order("created_at", { ascending: false })
          .limit(200);
        if (serial) {
          query = query.eq("serial", serial);
        }
        if (status) {
          query = query.eq("status", status);
        }
        const { data, error } = await query;
        if (error) {
          alert("提案の取得に失敗しました。");
          return;
        }
        renderProposalList(data || []);
      }

      function renderHistoryList(items) {
        const list = document.getElementById("historyList");
        const empty = document.getElementById("historyEmpty");
        if (!list || !empty) return;
        list.innerHTML = "";
        if (!items.length) {
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        items.forEach(item => {
          const wrap = document.createElement("div");
          wrap.className = "history-item";
          const meta = document.createElement("div");
          meta.className = "history-meta";
          const when = item.created_at ? new Date(item.created_at).toLocaleString() : "";
          meta.textContent = `${item.serial} / ${kindLabel(item.kind)} / ${when}`;
          wrap.appendChild(meta);
          const body = document.createElement("div");
          body.className = "history-body";
          body.textContent = formatHistoryBody(item);
          wrap.appendChild(body);
          const rollback = document.createElement("button");
          rollback.type = "button";
          rollback.textContent = "この版に戻す";
          rollback.addEventListener("click", () => {
            applyHistoryRollback(item);
          });
          wrap.appendChild(rollback);
          list.appendChild(wrap);
        });
      }

      function renderProposalList(items) {
        const list = document.getElementById("proposalList");
        const empty = document.getElementById("proposalEmpty");
        if (!list || !empty) return;
        list.innerHTML = "";
        if (!items.length) {
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        items.forEach(item => {
          const row = document.createElement("div");
          row.className = "proposal-row";
          const meta = document.createElement("div");
          meta.className = "proposal-meta";
          const when = item.created_at ? new Date(item.created_at).toLocaleString() : "";
          meta.textContent = `${item.serial} / ${kindLabelEdit(item.kind)} / ${when} / ${item.status || ""}`;
          row.appendChild(meta);
          const body = document.createElement("div");
          body.textContent = formatProposalSummary(item);
          row.appendChild(body);
          const actions = document.createElement("div");
          actions.className = "proposal-actions";
          const openBtn = document.createElement("button");
          openBtn.type = "button";
          openBtn.textContent = "この問題を開く";
          openBtn.addEventListener("click", () => {
            applyFilters({ keyword: item.serial });
          });
          actions.appendChild(openBtn);
          row.appendChild(actions);
          list.appendChild(row);
        });
      }

      function kindLabel(kind) {
        if (kind === "explanation") return "解説";
        if (kind === "case_text") return "症例文";
        if (kind === "stem") return "問題文";
        if (kind === "choices") return "選択肢";
        if (kind === "answer") return "模範解答";
        if (kind === "tags") return "タグ";
        if (kind === "subtopics") return "小項目";
        return kind || "";
      }

      function kindLabelEdit(kind) {
        if (kind === "explanation") return "解説";
        if (kind === "tag") return "タグ";
        if (kind === "subtopic") return "小項目";
        if (kind === "tags") return "タグ";
        if (kind === "subtopics") return "小項目";
        if (kind === "case_text") return "症例文";
        if (kind === "stem") return "問題文";
        if (kind === "choices") return "選択肢";
        if (kind === "answer") return "模範解答";
        return kind || "";
      }

      function formatProposalSummary(item) {
        const payload = item.payload || {};
        if (item.kind === "tag" || item.kind === "subtopic") {
          const add = Array.isArray(payload.add) ? payload.add : [];
          const remove = Array.isArray(payload.remove) ? payload.remove : [];
          return `追加: ${add.join(", ") || "(なし)"} / 削除: ${remove.join(", ") || "(なし)"} / コメント: ${item.note || ""}`;
        }
        if (item.kind === "explanation") {
          const body = payload.explanation || payload.body || "";
          return `解説: ${truncateText(body)} / コメント: ${item.note || ""}`;
        }
        if (item.kind === "case_text") {
          return `症例文: ${truncateText(payload.case_text || "")} / コメント: ${item.note || ""}`;
        }
        if (item.kind === "stem") {
          return `問題文: ${truncateText(payload.stem || "")} / コメント: ${item.note || ""}`;
        }
        if (item.kind === "choices") {
          const choices = Array.isArray(payload.choices) ? payload.choices : [];
          return `選択肢: ${truncateText(choices.join(" / "))} / コメント: ${item.note || ""}`;
        }
        if (item.kind === "answer") {
          const label = formatAnswerLabelFrom(payload);
          return `模範解答: ${label || "(未入力)"} / コメント: ${item.note || ""}`;
        }
        return item.note || "";
      }

      function formatHistoryBody(item) {
        const before = item.before_data || {};
        const after = item.after_data || {};
        if (item.kind === "explanation") {
          const beforeText = truncateText(before.explanation || "");
          const afterText = truncateText(after.explanation || "");
          const beforeLabel = formatExplanationLabel(before.explanation_source || "");
          const afterLabel = formatExplanationLabel(after.explanation_source || "");
          if (beforeText || afterText) {
            return `変更前${beforeLabel}: ${beforeText}\n変更後${afterLabel}: ${afterText}`;
          }
          return `変更前: ${before.explanation_source || "(空)"}\n変更後: ${after.explanation_source || "(空)"}`;
        }
        if (item.kind === "tags") {
          return `変更前: ${(before.tags || []).join(", ")}\n変更後: ${(after.tags || []).join(", ")}`;
        }
        if (item.kind === "subtopics") {
          return `変更前: ${(before.subtopics || []).join(", ")}\n変更後: ${(after.subtopics || []).join(", ")}`;
        }
        if (item.kind === "case_text") {
          return `変更前: ${truncateText(before.case_text || "")}\n変更後: ${truncateText(after.case_text || "")}`;
        }
        if (item.kind === "stem") {
          return `変更前: ${truncateText(before.stem || "")}\n変更後: ${truncateText(after.stem || "")}`;
        }
        if (item.kind === "choices") {
          const beforeText = Array.isArray(before.choices) ? before.choices.join(" / ") : "";
          const afterText = Array.isArray(after.choices) ? after.choices.join(" / ") : "";
          return `変更前: ${truncateText(beforeText)}\n変更後: ${truncateText(afterText)}`;
        }
        if (item.kind === "answer") {
          const beforeLabel = formatAnswerLabelFrom(before);
          const afterLabel = formatAnswerLabelFrom(after);
          return `変更前: ${beforeLabel || "(未入力)"}\n変更後: ${afterLabel || "(未入力)"}`;
        }
        return JSON.stringify(item.after_data || {});
      }

      function truncateText(text) {
        if (!text) return "";
        return text.length > 160 ? `${text.slice(0, 160)}…` : text;
      }

      function applyHistoryRollback(item) {
        if (!confirm("この版に戻しますか？")) return;
        const base = state.questions.find(q => q.serial === item.serial);
        const current = base ? applyOverridesToQuestion(base) : null;
        if (!current) {
          alert("対象の問題が見つかりません。");
          return;
        }
        if (item.kind === "tags") {
          const before = { tags: current.tags || [] };
          const next = (item.before_data && item.before_data.tags) || [];
          const after = { tags: next };
          applyOverrideChange(item.serial, "tags", before, after, { tags: next }, "rollback");
          return;
        }
        if (item.kind === "subtopics") {
          const before = { subtopics: current.subtopics || [] };
          const next = (item.before_data && item.before_data.subtopics) || [];
          const after = { subtopics: next };
          applyOverrideChange(item.serial, "subtopics", before, after, { subtopics: next }, "rollback");
          return;
        }
        if (item.kind === "explanation") {
          const before = {
            explanation: current.explanation_latest || "",
            explanation_source: current.explanation_latest_source || ""
          };
          const nextBody = item.before_data ? item.before_data.explanation : "";
          const nextSource = item.before_data ? item.before_data.explanation_source : "";
          const after = {
            explanation: nextBody || "",
            explanation_source: nextSource || ""
          };
          const patch = {
            explanation: after.explanation,
            explanation_source: after.explanation_source
          };
          applyOverrideChange(item.serial, "explanation", before, after, patch, "rollback");
        }
        if (item.kind === "case_text") {
          const before = { case_text: current.case_text || "" };
          const next = item.before_data ? item.before_data.case_text || "" : "";
          const after = { case_text: next };
          applyOverrideChange(item.serial, "case_text", before, after, { case_text: next }, "rollback");
        }
        if (item.kind === "stem") {
          const before = { stem: current.stem || "" };
          const next = item.before_data ? item.before_data.stem || "" : "";
          const after = { stem: next };
          applyOverrideChange(item.serial, "stem", before, after, { stem: next }, "rollback");
        }
        if (item.kind === "choices") {
          const before = { choices: current.choices || [] };
          const next = item.before_data ? item.before_data.choices || [] : [];
          const after = { choices: next };
          applyOverrideChange(item.serial, "choices", before, after, { choices: next }, "rollback");
        }
        if (item.kind === "answer") {
          const before = {
            answer_indices: getAnswerIndices(current),
            answer_none: Boolean(current.answer_none)
          };
          const next = item.before_data || {};
          const nextIndices = Array.isArray(next.answer_indices) ? next.answer_indices : [];
          const nextNone = Boolean(next.answer_none);
          const after = {
            answer_indices: nextNone ? [] : nextIndices,
            answer_none: nextNone
          };
          const patch = {
            answer_indices: after.answer_indices,
            answer_index: after.answer_indices[0] || null,
            answer_none: after.answer_none
          };
          applyOverrideChange(item.serial, "answer", before, after, patch, "rollback");
        }
      }

      function formatExplanationLabel(source) {
        if (!source) return "";
        if (source === "llm_checked") return "（AI承認済み）";
        if (source === "human" || source === "teacher") return "（教師編集）";
        if (source === "llm" || source === "ai") return "（AI）";
        return "（" + source + "）";
      }

      function getAnswerIndices(question) {
        if (!question) return [];
        const indices = Array.isArray(question.answer_indices)
          ? question.answer_indices.map(Number)
          : [];
        if (!indices.length && question.answer_index) {
          indices.push(Number(question.answer_index));
        }
        return indices.filter(n => Number.isFinite(n));
      }

      function isAnswerCorrect(question, selectedIndex) {
        if (!question) return false;
        if (question.answer_none) return true;
        const indices = getAnswerIndices(question);
        if (!indices.length) return false;
        return indices.includes(Number(selectedIndex));
      }

      function formatAnswerLabel(question) {
        if (!question) return "";
        if (question.answer_none) return "なし";
        const indices = getAnswerIndices(question);
        if (!indices.length) return "";
        return indices.join("・");
      }

      function formatAnswerLabelFrom(data) {
        if (!data) return "";
        if (data.answer_none) return "なし";
        const indices = Array.isArray(data.answer_indices)
          ? data.answer_indices.map(Number)
          : [];
        if (!indices.length && data.answer_index) {
          indices.push(Number(data.answer_index));
        }
        return indices.filter(n => Number.isFinite(n)).join("・");
      }

      function buildChoiceInputs(choices) {
        const wrap = document.createElement("div");
        wrap.className = "edit-grid";
        const inputs = [];
        (choices || []).forEach((choice, idx) => {
          const label = document.createElement("label");
          label.textContent = `選択肢${idx + 1}`;
          const input = document.createElement("input");
          input.type = "text";
          input.value = choice || "";
          label.appendChild(input);
          wrap.appendChild(label);
          inputs.push(input);
        });
        return { wrap, inputs };
      }

      function getChoiceInputValues(inputs) {
        return (inputs || []).map(input => (input.value || "").trim());
      }

      function buildAnswerSelector(choices, currentIndices, currentNone) {
        const wrap = document.createElement("div");
        wrap.className = "edit-grid";
        const indices = Array.isArray(currentIndices)
          ? currentIndices.map(Number).filter(n => Number.isFinite(n))
          : [];
        const noneLabel = document.createElement("label");
        const noneInput = document.createElement("input");
        noneInput.type = "checkbox";
        noneInput.checked = Boolean(currentNone);
        noneLabel.appendChild(noneInput);
        noneLabel.appendChild(document.createTextNode("解答なし"));
        wrap.appendChild(noneLabel);
        const checks = [];
        (choices || []).forEach((choice, idx) => {
          const label = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.value = String(idx + 1);
          cb.checked = indices.includes(idx + 1);
          label.appendChild(cb);
          const text = choice ? ` ${idx + 1}. ${choice}` : ` ${idx + 1}`;
          label.appendChild(document.createTextNode(text));
          wrap.appendChild(label);
          checks.push(cb);
        });
        const syncDisabled = () => {
          const disabled = noneInput.checked;
          checks.forEach(cb => {
            cb.disabled = disabled;
          });
        };
        noneInput.addEventListener("change", syncDisabled);
        syncDisabled();
        return {
          wrap,
          getValue: () => {
            if (noneInput.checked) {
              return { answer_none: true, answer_indices: [] };
            }
            const selected = checks
              .filter(cb => cb.checked)
              .map(cb => Number(cb.value))
              .filter(n => Number.isFinite(n));
            return { answer_none: false, answer_indices: selected };
          }
        };
      }

      function buildReportRequest(serial, kind, label) {
        const panelId = `report-${serial}-${kind}`.replace(/[^a-zA-Z0-9_-]/g, "-");
        const button = document.createElement("button");
        button.className = "request-btn";
        button.textContent = label;
        button.setAttribute("aria-label", `${label}を送信`);
        button.setAttribute("aria-expanded", "false");
        button.setAttribute("aria-controls", panelId);

        const panel = document.createElement("div");
        panel.className = "request-panel";
        panel.hidden = true;
        panel.id = panelId;

        const textarea = document.createElement("textarea");
        textarea.rows = 3;
        textarea.placeholder = "修正内容のコメント（必須）";
        textarea.setAttribute("aria-label", `${label}のコメント`);

        const error = document.createElement("div");
        error.className = "note";
        error.textContent = "コメントを入力してください。";
        error.hidden = true;

        const submit = document.createElement("button");
        submit.textContent = "送信";

        button.addEventListener("click", () => {
          panel.hidden = !panel.hidden;
          if (!panel.hidden) {
            textarea.focus();
          }
          button.setAttribute("aria-expanded", panel.hidden ? "false" : "true");
        });

        submit.addEventListener("click", () => {
          const comment = textarea.value.trim();
          if (!comment) {
            error.hidden = false;
            textarea.setAttribute("aria-invalid", "true");
            return;
          }
          error.hidden = true;
          textarea.removeAttribute("aria-invalid");
          sendReport(serial, kind, button, comment);
          textarea.value = "";
          panel.hidden = true;
          button.setAttribute("aria-expanded", "false");
        });

        panel.appendChild(textarea);
        panel.appendChild(error);
        panel.appendChild(submit);

        return { button, panel };
      }

      function handleAnswerSelection(question, selectedIndex, button) {
        if (hasSessionAnswered(question.serial)) {
          return;
        }
        const correctIndices = getAnswerIndices(question);
        const isCorrect = isAnswerCorrect(question, Number(selectedIndex));
        const buttons = button.closest("ol")?.querySelectorAll(".choice-btn") || [];
        buttons.forEach((btn, idx) => {
          btn.disabled = true;
          btn.classList.remove("selected", "correct", "incorrect");
          if (!question.answer_none && correctIndices.includes(idx + 1)) {
            btn.classList.add("correct");
          }
        });
        if (question.answer_none && isCorrect) {
          button.classList.add("correct");
        } else if (!isCorrect) {
          button.classList.add("incorrect");
        }
        const feedback = button.closest(".card")?.querySelector(".choice-feedback");
        if (feedback) {
          feedback.textContent = isCorrect ? "正解" : "不正解";
        }
        const card = button.closest(".card");
        if (card) {
          card.classList.add("show-explanation");
        }
        markAnswered(question.serial, selectedIndex, isCorrect);
        const retryBtn = card ? card.querySelector(".retry-btn") : null;
        if (retryBtn) {
          retryBtn.disabled = false;
        }
        const anonId = getAnonId();
        if (supabaseClient) {
          supabaseClient
            .from("answers")
            .insert([
              {
                serial: question.serial,
                is_correct: isCorrect,
                selected_index: selectedIndex,
                anon_id: anonId
              }
            ])
            .then(({ error }) => {
              if (error) {
                console.warn("回答の記録に失敗しました。", error);
              }
            });
        }
      }

      function hasAnswered(serial) {
        return Boolean(state.answeredMap[serial]);
      }

      function hasSessionAnswered(serial) {
        return Boolean(state.sessionAnswered[serial]);
      }

      function getSessionAnswered(serial) {
        return state.sessionAnswered[serial] || null;
      }

      function markAnswered(serial, selectedIndex, isCorrect) {
        state.sessionAnswered[serial] = {
          selectedIndex: Number(selectedIndex),
          isCorrect: Boolean(isCorrect)
        };
        state.answeredMap[serial] = {
          selectedIndex: Number(selectedIndex),
          isCorrect: Boolean(isCorrect)
        };
        saveAnsweredState();
      }

      function clearSessionAnswer(serial) {
        if (serial) {
          delete state.sessionAnswered[serial];
          return;
        }
        state.sessionAnswered = {};
      }

      function loadAnsweredState() {
        const key = "answeredSerials";
        const raw = localStorage.getItem(key);
        if (!raw) return;
        try {
          const map = JSON.parse(raw);
          if (map && typeof map === "object") {
            Object.keys(map).forEach(serial => {
              state.answeredMap[serial] = map[serial];
            });
          }
        } catch (err) {
          localStorage.removeItem(key);
        }
      }

      function saveAnsweredState() {
        const key = "answeredSerials";
        localStorage.setItem(key, JSON.stringify(state.answeredMap));
      }

      function loadTagVisibility() {
        const tagsRaw = localStorage.getItem("showTags");
        const subsRaw = localStorage.getItem("showSubtopics");
        if (tagsRaw !== null) {
          state.showTags = tagsRaw === "true";
        }
        if (subsRaw !== null) {
          state.showSubtopics = subsRaw === "true";
        }
        const tagsToggle = document.getElementById("showTagsToggle");
        const subsToggle = document.getElementById("showSubtopicsToggle");
        if (tagsToggle) tagsToggle.checked = state.showTags;
        if (subsToggle) subsToggle.checked = state.showSubtopics;
      }

      function saveTagVisibility() {
        localStorage.setItem("showTags", String(state.showTags));
        localStorage.setItem("showSubtopics", String(state.showSubtopics));
      }

      function filterDisabledTags(tags) {
        if (!tags || !tags.length) return [];
        if (!state.disabledTags || state.disabledTags.size === 0) return tags.slice();
        return tags.filter(tag => !state.disabledTags.has(tag));
      }

      function loadDisabledTags() {
        if (!supabaseClient) {
          state.disabledTags = new Set();
          return Promise.resolve();
        }
        return supabaseClient
          .from("tag_settings")
          .select("tag, disabled")
          .eq("disabled", true)
          .then(({ data, error }) => {
            if (error) {
              console.warn("無効タグの取得に失敗しました。", error);
              state.disabledTags = new Set();
              return;
            }
            const disabled = (data || [])
              .map(row => String(row.tag || "").trim())
              .filter(Boolean);
            state.disabledTags = new Set(disabled);
            renderDisabledTagList();
          });
      }

      function computeFrequentScores() {
        const questions = state.questions || [];
        let maxSession = 1;
        questions.forEach(q => {
          const value = Number(q.exam_session) || 0;
          if (value > maxSession) maxSession = value;
        });
        const tagScores = {};
        questions.forEach(q => {
          const subject = q.subject || "";
          const session = Number(q.exam_session) || 0;
          const weight = 1 + session / maxSession;
          const subtopics = (q.subtopics || []).length ? q.subtopics : [null];
          const tags = filterDisabledTags(q.tags || []);
          subtopics.forEach(subtopic => {
            const key = `${subject}||${subtopic || ""}`;
            if (!tagScores[key]) tagScores[key] = {};
            tags.forEach(tag => {
              tagScores[key][tag] = (tagScores[key][tag] || 0) + weight;
            });
          });
        });
        const topTagMap = {};
        const maxScoreMap = {};
        Object.keys(tagScores).forEach(key => {
          const entries = Object.entries(tagScores[key]).sort((a, b) => b[1] - a[1]);
          const top = entries.slice(0, 5);
          topTagMap[key] = top;
          maxScoreMap[key] = top.reduce((sum, item) => sum + item[1], 0);
        });
        questions.forEach(q => {
          const subject = q.subject || "";
          const tags = filterDisabledTags(q.tags || []);
          const subtopics = (q.subtopics || []).length ? q.subtopics : [null];
          let bestScore = 0;
          let bestTags = [];
          let bestKey = "";
          subtopics.forEach(subtopic => {
            const key = `${subject}||${subtopic || ""}`;
            const top = topTagMap[key] || [];
            if (!top.length) return;
            const topMap = {};
            top.forEach(([tag, score]) => {
              topMap[tag] = score;
            });
            const matched = tags.filter(tag => topMap[tag]);
            if (!matched.length) return;
            const score = matched.reduce((sum, tag) => sum + topMap[tag], 0);
            if (score > bestScore) {
              bestScore = score;
              bestTags = matched.sort((a, b) => topMap[b] - topMap[a]).slice(0, 2);
              bestKey = key;
            }
          });
          const maxScore = bestKey ? (maxScoreMap[bestKey] || 0) : 0;
          let level = 0;
          if (bestScore > 0 && maxScore > 0) {
            const ratio = bestScore / maxScore;
            level = ratio >= 0.66 ? 3 : ratio >= 0.33 ? 2 : 1;
          }
          q.frequent_score = Math.round(bestScore * 1000) / 1000;
          q.frequent_level = level;
          q.frequent_tags = bestTags;
        });
      }

      function initTagDisablePanel() {
        const addBtn = document.getElementById("disableTagAddBtn");
        const input = document.getElementById("disableTagInput");
        if (!addBtn || !input) return;
        addBtn.addEventListener("click", async () => {
          const session = state.teacherSession;
          if (!session || !session.user) {
            alert("教師ログインが必要です。");
            return;
          }
          const tags = input.value
            .split(",")
            .map(t => t.trim())
            .filter(Boolean);
          if (!tags.length) {
            alert("タグを入力してください。");
            return;
          }
          for (const tag of tags) {
            await supabaseClient
              .from("tag_settings")
              .upsert(
                [
                  {
                    tag,
                    disabled: true,
                    updated_at: new Date().toISOString(),
                    updated_by: session.user.id
                  }
                ],
                { onConflict: "tag" }
              );
          }
          input.value = "";
          await loadDisabledTags();
          computeFrequentScores();
          renderResults(filterQuestions());
        });
      }

      function renderDisabledTagList() {
        const list = document.getElementById("disabledTagList");
        if (!list) return;
        list.innerHTML = "";
        const tags = Array.from(state.disabledTags || []).sort();
        if (!tags.length) {
          const empty = document.createElement("div");
          empty.className = "note";
          empty.textContent = "無効化されたタグはありません。";
          list.appendChild(empty);
          return;
        }
        tags.forEach(tag => {
          const row = document.createElement("div");
          row.className = "row";
          const label = document.createElement("span");
          label.textContent = tag;
          row.appendChild(label);
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = "解除";
          btn.addEventListener("click", async () => {
            const session = state.teacherSession;
            if (!session || !session.user) {
              alert("教師ログインが必要です。");
              return;
            }
            await supabaseClient.from("tag_settings").delete().eq("tag", tag);
            await loadDisabledTags();
            computeFrequentScores();
            renderResults(filterQuestions());
          });
          row.appendChild(btn);
          list.appendChild(row);
        });
      }

      function getAnonId() {
        const key = "anonId";
        let id = localStorage.getItem(key);
        if (id) return id;
        if (crypto && crypto.randomUUID) {
          id = crypto.randomUUID();
        } else {
          id = `${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
        }
        localStorage.setItem(key, id);
        return id;
      }

      function buildFilterHeader() {
        const keyword = document.getElementById("keyword").value.trim();
        const subject = document.getElementById("subjectSelect").value;
        const subtopic = document.getElementById("subtopicSelect").value;
        const examType = document.getElementById("examTypeSelect").value;
        const sessionFrom = document.getElementById("sessionFrom").value;
        const sessionTo = document.getElementById("sessionTo").value;
        const sortSession = document.getElementById("sortSession").value;
        const showAnswered = document.getElementById("showAnswered").checked;
        const onlyFrequent = document.getElementById("onlyFrequent").checked;
        const parts = [];
        if (keyword) parts.push(`キーワード: ${keyword}`);
        if (subject) parts.push(`科目: ${subject}`);
        if (subtopic) parts.push(`小項目: ${subtopic}`);
        if (examType) parts.push(`種別: ${examType}`);
        if (sessionFrom || sessionTo) {
          const fromLabel = sessionFrom ? `${sessionFrom}回` : "";
          const toLabel = sessionTo ? `${sessionTo}回` : "";
          const range = [fromLabel, toLabel].filter(Boolean).join("〜");
          parts.push(`回数範囲: ${range || "指定なし"}`);
        }
        if (sortSession) {
          const sortLabels = {
            asc: "古い順",
            desc: "新しい順",
            frequent_desc: "頻出順",
            frequent_asc: "頻出（低い順）",
            count_desc: "回答数が多い順",
            count_asc: "回答数が少ない順",
            correct_desc: "正答数が多い順",
            correct_asc: "正答数が少ない順",
            rate_desc: "正答率が高い順",
            rate_asc: "正答率が低い順"
          };
          const label = sortLabels[sortSession] || "新しい順";
          parts.push(`並び替え: ${label}`);
        }
        if (onlyFrequent) parts.push("頻出のみ");
        if (showAnswered) parts.push("回答済みを表示");
        return parts.length ? `検索条件: ${parts.join(" / ")}` : "検索条件: なし";
      }

      function getCopyMode() {
        const showAnswer = document.getElementById("toggleAnswer").checked;
        const showExplanation = document.getElementById("toggleExplanation").checked;
        return {
          showAnswer: showAnswer || showExplanation,
          showExplanation: showExplanation
        };
      }

      function formatQuestionForCopy(q, mode) {
        const showAnswer = mode && mode.showAnswer;
        const showExplanation = mode && mode.showExplanation;
        const lines = [];
        if (q.case_text) {
          lines.push(q.case_text);
        }
        lines.push(`${q.serial}　${q.stem || ""}`);
        const choices = q.choices || [];
        const nums = ["１", "２", "３", "４", "５", "６", "７", "８", "９"];
        choices.forEach((choice, idx) => {
          const n = nums[idx] || String(idx + 1);
          lines.push(`${n}．${choice}`);
        });
        if (showAnswer) {
          lines.push("　");
          let ansLabel = "";
          if (q.answer_none) {
            ansLabel = "なし";
          } else {
            const indices = getAnswerIndices(q);
            if (indices.length) {
              ansLabel = indices
                .map(idx => nums[idx - 1] || String(idx))
                .join("・");
            }
          }
          const ans = ansLabel ? `解答　${ansLabel}` : "解答　";
          lines.push(ans);
          if (showExplanation) {
            const exp = q.explanation_latest || "";
            if (exp) {
              lines.push("解説");
              lines.push(exp);
            }
          }
        }
        return lines.join("\n");
      }

      function formatDeepDivePrompt(q) {
        const lines = [];
        lines.push("以下の問題について徐々に深化して深掘りするよう解説してください。");
        if (q.case_text) {
          lines.push(q.case_text);
        }
        lines.push(q.stem || "");
        const choices = q.choices || [];
        choices.forEach((choice, idx) => {
          lines.push(`${idx + 1}．${choice}`);
        });
        const answerLabel = formatAnswerLabel(q);
        if (answerLabel) {
          lines.push(`解答　${answerLabel}`);
        }
        return lines.filter(Boolean).join("\n");
      }

      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text);
          return;
        }
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        textarea.remove();
      }
    </script>
  </body>
</html>
